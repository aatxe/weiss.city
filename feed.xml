<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Aaron Weiss / Recent Posts</title>
  <subtitle>Personal Blog of Aaron Weiss</subtitle>
  <link href="https://aaronweiss.us/feed.xml" rel="self"/>
  <link href="https://aaronweiss.us/"/>
  <updated>2020-01-27T00:00:00Z</updated>
  <id>https://aaronweiss.us/</id>
  <author>
    <name>Aaron Weiss</name>
    <email>aweiss@hey.com</email>
  </author>
  
  <entry>
    <title>HSCTF Write-Ups</title>
    <link href="https://aaronweiss.us/posts/2014-05-26-hsctf-write-ups/"/>
    <updated>2014-05-26T00:00:00Z</updated>
    <id>https://aaronweiss.us/posts/2014-05-26-hsctf-write-ups/</id>
    <content type="html">&lt;p&gt;As an organizer of the recent High School CTF competition, &lt;a href=&quot;http://hsctf.com/&quot;&gt;HSCTF&lt;/a&gt;, I designed a series of problems for competitors to take part in. My primary focus in problem design for the competition was in reverse engineering, but I also created one of the most challenging reconnaissance problem we offered in the competition. Since the competition is now complete, I&#39;ll be posting a series of write-ups on the problems I designed. In each write-up, I&#39;ll discuss the problem, the ideas that went into the design, the solution, pitfalls that users fell into, and any other interesting information about the problem.&lt;/p&gt;
&lt;p&gt;The competition itself was wildly successful with over 750 teams registered, and over 2,100 participants. We offered 45 problems (and a survey) coming to a total of 14,250 points (50 points for the survey). We had a highly competitive top fifty with many teams able to jump quickly in the ranks by solving one problem. It was a close competition for sure. In fact, Raelly didn&#39;t jump into the first position until the closing hour or two of the competition.&lt;/p&gt;
&lt;p&gt;With that, I&#39;d like to congratulate all of our participants in HSCTF. This was a wonderful competition and I&#39;m deeply pleased with how well it went. Hard problems were solved. The competition was fierce. Everyone did a wonderful job. Specifically, I&#39;d like to congratulate The Lumberjacks from Phillips Academy for placing third, 0x90.avi from Thomas Jefferson High School for placing second, and Raelly from Thomas Jefferson High School for Science and Technology for their last-minute steal of first place. This is especially impressive since they joined the competition rather late. Well played, everyone!&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>Write-Up: awe</title>
    <link href="https://aaronweiss.us/posts/2014-05-26-write-up-awe/"/>
    <updated>2014-05-26T00:00:00Z</updated>
    <id>https://aaronweiss.us/posts/2014-05-26-write-up-awe/</id>
    <content type="html">&lt;p&gt;As part of HSCTF, there was a reconnaissance problem entitled awe. The given text for the problem was simple, and generally unhelpful as it was part of a series on some of our organizers. The text read &amp;quot;My name is Aaron Weiss.&amp;quot; The problem was, as you could probably tell, about me.&lt;/p&gt;
&lt;p&gt;The task of finding the flag was broken up into two pairs of &lt;code&gt;#, word&lt;/code&gt; in two different places on the web. The hope was that when all four parts (two pairs from two sources) were found, they could be assembled into the flag using the order from the numbers accompanying the words. The format was designed purposefully to look suspicious and to draw attention across the web. The problem never intended for people to just guess random pieces of information.&lt;/p&gt;
&lt;p&gt;The first pair was found in two GitHub repositories, &lt;a href=&quot;https://github.com/aatxe/dc-anchor/commit/fdf059c097e1f2fbe5d988dd2fca74e1e984857b#L13&quot;&gt;dc-anchor&lt;/a&gt; and &lt;a href=&quot;https://github.com/aatxe/juicebot/commit/31c8e338d1b939f79c413ded9bae31b0a8013e10#L2&quot;&gt;juicebot&lt;/a&gt;. As something of a gotcha, the first repository had another &lt;a href=&quot;https://github.com/aatxe/dc-anchor/commit/6591b8d28ce6f6c3c626babdcf1c9b357182a317#L13&quot;&gt;commit&lt;/a&gt; wherein I had removed a flag from an old CTF we ran. Many teams got caught up thinking this was important, even despite the note I added saying it wasn&#39;t. This probably helped to add to the confusion, as this old flag was found by a great many participants.&lt;/p&gt;
&lt;p&gt;The other two pieces were found on the &lt;a href=&quot;http://www.fyrechat.net/&quot;&gt;FyreChat IRC Network&lt;/a&gt;. The first one was found in the channel description of the channel &lt;code&gt;#awe&lt;/code&gt;. This could be found by using the command &lt;code&gt;/msg ChanServ LIST *&lt;/code&gt; and reading through the results. It was actually the first result. Then, upon joining the channel, the topic was set with the remaining piece. Many teams found this last part by doing &lt;code&gt;/whois awe&lt;/code&gt; and joining all of the channels I was in. This approach cheated them out of the channel description, and ultimately complicated the problem.&lt;/p&gt;
&lt;p&gt;Once all the parts were found, the key could then be formed. Any combination that featured the words in the proper order, regardless of separators, would be considered correct. Valid keys could&#39;ve been &lt;code&gt;aweiskindanew&lt;/code&gt; or &lt;code&gt;awe is kinda new&lt;/code&gt; or anything else to that effect. That would all suffice.&lt;/p&gt;
&lt;p&gt;Many teams got caught up in searching for particular information about me and making guesses based on that information. This resulted in a variety of funny submissions that were all generally unrelated to me. Many of these submissions were related to an Iraq war veteran and a video wherein he challenged New York&#39;s SAFE Act. Others were related to a seemingly insignificant secondary character in a book entitled the Trikon Deception. Here&#39;s a sampling of some of the submissions: &lt;code&gt;2nd Amendment&lt;/code&gt;, &lt;code&gt;awe is really cool&lt;/code&gt;, &lt;code&gt;SAFE Act&lt;/code&gt;, &lt;code&gt;My right is greater than your dead&lt;/code&gt;, and &lt;code&gt;Gun Control&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Based on the history of the problem, it should be rather apparent that it was a lot harder than it originally seemed to me as the author. The problem was originally set to be a 300 point problem, but was raised to a 400 point problem prior to the competition. Half way through the competition, the problem remained unsolved and so it was raised to 500 points. Ultimately, the problem was not solved during the competition.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>Write-Up: λ1</title>
    <link href="https://aaronweiss.us/posts/2014-06-04-write-up-l1/"/>
    <updated>2014-06-04T00:00:00Z</updated>
    <id>https://aaronweiss.us/posts/2014-06-04-write-up-l1/</id>
    <content type="html">&lt;p&gt;As part of HSCTF, there was a reverse engineering problem entitled &amp;quot;λ1&amp;quot;. The problem text was short and to the point &amp;quot;Here&#39;s the lock. Find the key.&amp;quot; The first phrase &lt;a href=&quot;http://compete.hsctf.com/ciJsbu4VFk/%CE%BB1.zip&quot;&gt;&amp;quot;Here&#39;s the lock.&amp;quot;&lt;/a&gt; linked to an archive containing three executables, one for each of the major operating systems. All three executables were 64-bit. This problem is the first of a series of reversing problems.&lt;/p&gt;
&lt;p&gt;Ultimately, the goal of this problem was to retrieve the flag from one of the given executables. As a result, there&#39;s a wide assortment of approaches to this problem. I&#39;m not going to go over all of them here because I certainly don&#39;t think I could produce all of them. Instead, I&#39;m going to go over the approach that I anticipated as the most common solution to the problem. In fact, it&#39;s possible that this wasn&#39;t even the most common solution. Regardless, we&#39;ll carry forward.&lt;/p&gt;
&lt;p&gt;Recognizing that the problem is one of reverse engineering, my first reaction is to immediately fire up &lt;a href=&quot;https://www.hex-rays.com/products/ida/index.shtml&quot;&gt;IDA&lt;/a&gt;. Upon attempting to open the executable, IDA fails to do so because of the lambda in the file name. So, I rename it to &lt;code&gt;llama.exe&lt;/code&gt; and try again to open it. This time, it works out. Next, I will attempt to run the program.&lt;/p&gt;
&lt;figure data-type=&quot;image&quot;&gt;&lt;img src=&quot;https://aaronweiss.us/images/L1-Screen1.png&quot; alt=&quot;Running llama.&quot; /&gt;&lt;/figure&gt;
&lt;p&gt;Upon entering input, I notice that the program quickly ends, but I can catch that the output of the program depends on the value I input. I also notice that when I enter non-numbers, the program outputs a parsing error before exiting. Therefore, I can assume that the input needs to be a number. Since the output changes based on the input and there&#39;s no additional files included with these programs, I can assume that the information I&#39;m looking for has to be stored in the executable in some form. So, let&#39;s look at the string table.&lt;/p&gt;
&lt;figure data-type=&quot;image&quot;&gt;&lt;img src=&quot;https://aaronweiss.us/images/L1-Screen2.png&quot; alt=&quot;Looking at the string table.&quot; /&gt;&lt;/figure&gt;
&lt;p&gt;Well, what&#39;s this? It mentions GHC and RTS. If you didn&#39;t know what these things were, a quick search on &lt;a href=&quot;https://duckduckgo.com/?q=GHCRTS&quot;&gt;DuckDuckGo&lt;/a&gt; will reveal that GHC is the primary Haskell compiler and that the RTS is the Haskell runtime. Therefore, we now know that this is a Haskell executable made with GHC. As a result, we also know that the &lt;code&gt;.data&lt;/code&gt; section is entirely runtime related data and that &lt;code&gt;.rodata&lt;/code&gt; is going to hold actual variables from our program. After all, Haskell is an immutable language and as a result, data is read-only. So, let&#39;s pull that up.&lt;/p&gt;
&lt;figure data-type=&quot;image&quot;&gt;&lt;img src=&quot;https://aaronweiss.us/images/L1-Screen3.png&quot; alt=&quot;Looking at .rodata.&quot; /&gt;&lt;/figure&gt;
&lt;p&gt;As it turns out, the first string in &lt;code&gt;.rodata&lt;/code&gt; is a suspicious looking string and everything that follows it is denoted as being part of the base Haskell package. From this, we can infer that Haskell includes constants from the actual software as the first entry and then follows it with other strings from within &lt;code&gt;Prelude&lt;/code&gt;. So, now, we need to figure out what to do with this string we found. Here it is: &lt;code&gt;Â°Â¥Â±Â¦Â¨Â¥Â·ÃƒÂ¥Â¶Â©ÃƒÂ¯Â­Â²Â«&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Judging from some of the previous problems in HSCTF and the fact that the majority of the string consists of accented capital A characters, my first guess would be that it&#39;s a Caesar cipher. After all, this suggests that there&#39;s a pretty tight grouping in values. So, we&#39;re going to have to build some sort of Caesar cipher solver to attempt this approach.&lt;/p&gt;
&lt;p&gt;Here&#39;s our Python script:&lt;/p&gt;
&lt;pre class=&quot;language-python&quot;&gt;&lt;code class=&quot;language-python&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;shifter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;s&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;token keyword&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;token builtin&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;129&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;128&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;try&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;br /&gt;      &lt;span class=&quot;token keyword&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;      &lt;span class=&quot;token keyword&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;lambda&lt;/span&gt; z&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;y&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;join&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token builtin&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;lambda&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;token builtin&quot;&gt;chr&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token builtin&quot;&gt;ord&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt;y&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;256&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;z&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;s&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;i&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;except&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;br /&gt;      &lt;span class=&quot;token keyword&quot;&gt;pass&lt;/span&gt;&lt;br /&gt;shifter&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;&#92;xb0&#92;xa5&#92;xb1&#92;xa6&#92;xa8&#92;xa5&#92;xb7&#92;xc3&#92;xa5&#92;xb6&#92;xa9&#92;xc3&#92;xaf&#92;xad&#92;xb2&#92;xab&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The script works by going over all possible shifts within a byte and outputting our input string shifted by each amount. For the actual input, you&#39;ll see that we had to use an ASCII table to convert the string into a format that Python could handle. This step may be optional depending on the language used for this part of the problem. Once this is done, let&#39;s explore the output.&lt;/p&gt;
&lt;figure data-type=&quot;image&quot;&gt;&lt;img src=&quot;https://aaronweiss.us/images/L1-Screen4.png&quot; alt=&quot;Output from shifter.&quot; /&gt;&lt;/figure&gt;
&lt;p&gt;Well, look at that. We searched through the input a little and we found something very, very suspicious. This string, &lt;code&gt;LAMBDAS_ARE_KING&lt;/code&gt;, looks like it could be the key. In fact, it is indeed the key. We did it!&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>Worker Appreciation Day</title>
    <link href="https://aaronweiss.us/posts/2014-10-21-worker-appreciation-day/"/>
    <updated>2014-10-21T00:00:00Z</updated>
    <id>https://aaronweiss.us/posts/2014-10-21-worker-appreciation-day/</id>
    <content type="html">&lt;p&gt;As a member of the Student Labor Action Project, I wrote an opinion-editorial for UMass&#39; Daily Collegian. It was published October 30th, and is available online &lt;a href=&quot;http://dailycollegian.com/2014/10/30/appreciating-campus-workers/&quot;&gt;here&lt;/a&gt;. Additionally, it is reproduced exactly as I wrote it below.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Today is Worker Appreciation Day. The Student Labor Action Project (SLAP) is hosting a brunch to show gratitude to the many workers of UMass. We’d like to encourage other students to do their part in expressing their gratitude to those with whom they interact. Workers make UMass work. They clean our dishes, our floors, and our showers. They fix our heating, sell us books, and run the on-campus hotel. Perhaps most importantly, they make our food. Do we, as students, consider the significance that workers have in our everyday lives? Without UMass workers, we could not have the incredible experiences made available to us at this institution. So, what do they get in return?&lt;/p&gt;
&lt;p&gt;The University of Massachusetts is one of the largest minimum wage employers in the state. Working a traditional 2,000-hour work-year at the minimum wage nets a whopping $16,000 per year. According to the &lt;a href=&quot;http://aspe.hhs.gov/poverty/14poverty.cfm&quot;&gt;Department of Health and Human Services&lt;/a&gt;, the poverty line for a family of four is $23,850 per year. According to the &lt;a href=&quot;https://web.archive.org/web/20140830112333/http://quickfacts.census.gov/qfd/states/25/2501360.html&quot;&gt;United States Census Bureau&lt;/a&gt;, Amherst Center has a poverty rate of 30.5%, roughly three times the state average of 11%. It’s no wonder roughly a third of the people living in Amherst and the surrounding towns are living below the poverty line. Given its size, our university has a profound impact on the areas surrounding it, but chooses to do the bare minimum to keep its workers out of poverty.&lt;/p&gt;
&lt;p&gt;On top of this, the university keeps workers from their rightfully-deserved benefits, violating the spirit of a court ruling in 1979 (&lt;a href=&quot;https://www.dropbox.com/s/jql67cos5zn3nni/Berwald%20v.%20Board%20of%20Trustees.pdf?dl=0&quot;&gt;Berwald et al. v. The UMass Board of Trustees&lt;/a&gt;). In the ruling, the court determined that it was unlawful for the university to keep workers serving a non-temporary function as a temporary, or 03, worker for more than one year. Yet thirty five years later, the university keeps long-time workers under this temporary designation by firing and rehiring them every year such that they never technically work long enough to warrant promotion under the terms of the ruling. As temporary workers, they are denied crucial benefits such as health and dental care.&lt;/p&gt;
&lt;p&gt;The 03s fought back against this abuse in 2011 by unionizing. After three years of unionization, the 03s continue to work without contract as the university has kept them in a perpetual state of bargaining. As Ben Walton wrote earlier this year, continued bargaining has even been used by the administration to deny workers raises. Combined with inflation, the lives of essential workers are only getting harder, and they deserve better. As students of this institution, we pay a great deal of money and there’s no reason that those who feed us should not be able to feed themselves.&lt;/p&gt;
&lt;p&gt;SLAP urges students to do their part in demanding economic justice for all UMass workers because they fundamentally shape our experience here and deserve far, far better than they have now. We need to band together in support of our workers; doing otherwise supports the status quo. We need their support, and right now, they need ours.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>A Brief History of Pdgn</title>
    <link href="https://aaronweiss.us/posts/2015-02-11-history-of-pdgn/"/>
    <updated>2015-02-11T00:00:00Z</updated>
    <id>https://aaronweiss.us/posts/2015-02-11-history-of-pdgn/</id>
    <content type="html">&lt;p&gt;This is a cross-post from the &lt;a href=&quot;http://blog.pdgn.co/&quot;&gt;PdgnCo Community Blog&lt;/a&gt;. It was published on
February 11th, 2015, and can also be found
&lt;a href=&quot;http://blog.pdgn.co/general/2015/02/11/history-of-pdgn.html&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;The idea for Pdgn first came in June of 2014. For reasons that I can&#39;t recall, I was drawn to
searching for a domain. I didn&#39;t really have a purpose for it. I was just poking around to see if
anything cool was available. I stumbled upon the domain &lt;code&gt;pdgn.co&lt;/code&gt;, and I thought it was concise,
oddly charming, and easily pronouncable (as the English word, pigeon). As I said, I didn&#39;t have a
purpose, and so, I didn&#39;t purchase the domain. I did, however, keep it in my mind.&lt;/p&gt;
&lt;p&gt;Around this time, my productivity levels had plummetted immensely. I had begun to loathe working in
Java, and my constant attempts to take on incredibly large projects were going nowhere. I&#39;d been
trying to learn Haskell on-and-off for roughly a year, and I&#39;d fallen completely in love with
functional programming as a paradigm. In another IRC network that I call home
(&lt;a href=&quot;http://www.fyrechat.net/&quot;&gt;FyreChat&lt;/a&gt;), I&#39;d also been exposed to Rust. I didn&#39;t really think of
myself as capable of programming in a systems language, but I liked that Rust had many of the nice
idioms that I had come to appreciate from my struggles with Haskell. So, I wanted to jump ship from
Java, and I was looking at both Rust and Haskell. However, I didn&#39;t have any ideas of reasonable
things to work on once I did. That changed in July.&lt;/p&gt;
&lt;p&gt;In July of that year, as the next step in a big push to distance myself from Google, I had decided
that I wanted to run a small, privacy-first email service and that I wanted to write all the
software myself. I had some experience with IRC as a protocol, and I figured that the email
protocols couldn&#39;t be that much worse. So, I bought the domain. I tried to make the decision of
whether I wanted to write it in Rust or Haskell. Rust would be hard because I was scared of the
idea of having to manage memory myself, and Haskell would be hard because I was still struggling to
understand how to work with state and the real world. Ultimately, at the urging of some friends, I
decided that I would write the service in Rust. I also decided that I may as well combine it with a
privacy-first chat service as well. My goal was to incorporate the best privacy practices available
for existing protocols, and thus I wasn&#39;t going to invent a new chat client or a new email protocol
and so on.&lt;/p&gt;
&lt;p&gt;Still, even with an idea, my motivation was pretty low. I looked at the task of learning a new
language as an impossibly high barrier, and much like previous projects, I worried that it was too
large of a task for me to finish. Having already assured some of my friends that it would happen, I
continually put off the idea and then put it off again. By the time summer ended, I had made no
progress at all on my goal, and had made no effort to learn Rust. My friend
&lt;a href=&quot;http://www.jacobedelman.com/&quot;&gt;Jacob&lt;/a&gt; bugged me countless times about writing the service because he
wanted a new email address himself, but even that had done nothing to drive progress.&lt;/p&gt;
&lt;p&gt;I was about to start University, and I stopped to look back at what I had done on the summer. When
I did, I was saddened to see that I had done just about nothing and I wondered why. I wrote a
&lt;a href=&quot;http://aaronweiss.us/posts/2014-08-26-summers-gone.html&quot;&gt;blog post&lt;/a&gt; about it, and decided that I
needed to do things differently. So when I started school, I decided that I was going to learn
Rust by working with something familiar before doing anything unfamiliar. Dungeons and Dragons, 5th
Edition was released around this time, and I wanted to play it with people over IRC. So, I thought
that it would be a good opportunity to write an IRC bot to run the game. There was a clear path to
starting off small, and a clear path for it to be more complicated. So, it seemed like a great
first project. I split the project into two parts, &lt;a href=&quot;https://github.com/aatxe/irc&quot;&gt;the IRC library&lt;/a&gt;
and &lt;a href=&quot;https://github.com/aatxe/dnd&quot;&gt;the bot&lt;/a&gt; itself, and I set off to learn Rust.&lt;/p&gt;
&lt;p&gt;From September 10th on, I was throwing all the free time that I could muster into this bot. Bored
in my data structures class, I started using that time to work on it, too. Once I got over the hump
of struggling with the language (and especially lifetimes), I started making good progress. I
knocked out a lot of the features I had planned, and by the end of October, I found myself looking
mostly at some of the harder stuff. I wanted to implement a battle map, and that required an
associated web server component. I was worried about how hard it was going to be, and so I went
looking elsewhere for places to continue my learning of Rust. Eventually, it occurred to me that a
part of my goal had been to run an IRC server in Rust. I obviously couldn&#39;t write it immediately,
but I could definitely launch a server with an existing IRCd and make it a long-term project.&lt;/p&gt;
&lt;p&gt;With that, on October 27th, 2014, Pdgn as an IRC network was born. I reached out to my high school
friends Jacob and Alok, and asked them to join. We had run an online computer science competition
earlier in the year (&lt;a href=&quot;http://hsctf.com/&quot;&gt;HSCTF&lt;/a&gt;), and I had missed being able to interact with them
over IRC. In what can only be described as perfect timing, &lt;a href=&quot;https://picoctf.com/&quot;&gt;PicoCTF&lt;/a&gt; had also
started that day. This meant that Jacob and Alok, both participating in it, were immediately in
contact with many of the participants of HSCTF who spent their time in our IRC channel on Mibbit
during and after the competition. The channel had all but completely disappated by this time, and
so I hadn&#39;t really heard from any of them. They both took this as an opportunity to recruit, and
they convinced a number of old friends (and former HSCTF participants) to join the network. Slowly,
but surely, we garnered a small userbase.&lt;/p&gt;
&lt;p&gt;Seeing all the progress that was made in a day, I immediately started work on our own set of IRC
services written in Rust. I didn&#39;t have a lot of knowledge about how they were implemented, and so,
I assumed that they were just normal bots. For anyone looking to not replicate my mistake, services
are almost always implemented as a separate server linked to the main hub. Regardless, I carried on
blindly. Within two days, nickname and channel registration was implemented. The services were
starting to shape up, and I was excited to be putting them to immediate use. One issue I
encountered along the way was that the user mode marking that you&#39;re identified (&lt;code&gt;+R&lt;/code&gt;) is actually
only able to be set by a server. I didn&#39;t have a server component to my IRC library, and I knew
that that would be a huge investment. So, I modified the &lt;code&gt;m_samode&lt;/code&gt; module for InspIRCd to allow
operators to set the mode &lt;code&gt;+R&lt;/code&gt; with the &lt;code&gt;SAMODE&lt;/code&gt; command. I was the only server operator, and so I
figured that it wouldn&#39;t be much of an issue. With that, the bot was able to mark people as being
identified.&lt;/p&gt;
&lt;p&gt;A few days later, I found myself joining a discussion on the Mozilla IRC about IRC libraries in
Rust. As far as I knew, my library was the only one that built on the latest Rust, as many of the
previous developers had abandoned their work. While my library worked fine for my purposes, others
were critical of my use of callbacks to define IRC functionality. Another developer who had
previously worked on an IRC library pointed me in the direction of a better design. They
recommended that I take advantage of iterators because of all of the sugar associated with them in
Rust. So,
&lt;a href=&quot;https://github.com/aatxe/irc/tree/91aa5bcc6f5a2380bb2348274432b34d86b03ace&quot;&gt;on November 2nd&lt;/a&gt;, I
did a large refactor of my IRC library. I dropped a lot of the excess, and implemented an
iterator-based design. From there, I started down a long path of improving the library. I wrote a
collection of utility functions that evolved into a utility wrapper to the server objects. I
rewrote tons of unit tests. I added SSL support, and working user tracking with access level
support. I dealt with crate name squatting on the Rust &lt;a href=&quot;https://crates.io/&quot;&gt;crate repository&lt;/a&gt;, and
eventually claimed the crate name &lt;code&gt;irc&lt;/code&gt;. I made the library thread-safe, and fully specification
compliant. The library grew into something substantial, and I was happy for it.&lt;/p&gt;
&lt;p&gt;Both bots weathered the storm of the redesign, and while the Dungeons and Dragons bot had
stagnated, the services bot continued to grow and expand. At Jacob&#39;s urging, I implemented the game
&lt;a href=&quot;https://en.wikipedia.org/wiki/The_Resistance_(game)&quot;&gt;Resistance&lt;/a&gt; as an optional feature for it. I
also added a counter to track stupid mistakes, and a full-featured voting-based administration
tool. The idea was to use the bot (named Pidgey, and declared our mascot) to allow fully democratic
channel administration. We found out quickly that this was less than desirable. People started lots
of non-sense votes, and rarely did votes ever pass. Eventually, I retired the democracy feature,
and Pidgey went back to just managing channel and nickname registration (with Resistance and derps
on the side). The server kept on running.&lt;/p&gt;
&lt;p&gt;After a few months, it became more apparent that running an IRC network on a single server was less
than desirable. I wasn&#39;t able to do updates of any kind, and maintenance meant that everything was
completely inaccessible. So, I set out to make Pdgn into an actual network instead. The first step
was to &lt;a href=&quot;http://aaronweiss.us/posts/2015-02-03-going-static.html&quot;&gt;move my site off of Ghost&lt;/a&gt;, which
was being hosted on the same server as the IRC network. Once that was done, I got two new, smaller
servers for the network. One in San Fransisco, and one in New York. I had to decide on names, and
I wanted an overarching theme for them. So, I settled on
&lt;a href=&quot;http://dictionary.reference.com/browse/genus&quot;&gt;genera&lt;/a&gt; of pigeons as an appropriate name. The
hub server in New York was named &lt;a href=&quot;https://en.wikipedia.org/wiki/Columba_(genus)&quot;&gt;Columba&lt;/a&gt;, after
the genus of typical Old World pigeons. The server in San Fransisco was named
&lt;a href=&quot;https://en.wikipedia.org/wiki/Dodo&quot;&gt;Raphus&lt;/a&gt;, after the genus of the dodo (which is, to some
people&#39;s suprise including my own, a type of pigeon!).&lt;/p&gt;
&lt;p&gt;On February 3rd, 2015, both of the new servers went live, and the original server that housed Pdgn
was taken down. With this, the original services bot was also retired.
&lt;a href=&quot;https://github.com/Pdgn/site/tree/fa533c0f976470211ca41f689c45001dd270ee67&quot;&gt;On February 9th&lt;/a&gt;, I
released an official &lt;a href=&quot;http://pdgn.co/&quot;&gt;pdgn.co site&lt;/a&gt;, and then
&lt;a href=&quot;https://github.com/Pdgn/blog/tree/919e50226dd6e68e69ef85dda4c6ce73e72a6075&quot;&gt;on February 10th&lt;/a&gt;, I
released the official &lt;a href=&quot;http://blog.pdgn.co/&quot;&gt;pdgn.co community blog&lt;/a&gt;. This brings us to today,
February 11th, where I have now, for the first time, documented the history of the network. It&#39;s
hard to say where the future will take us, but I hope to expand the network with more servers and
more people. This is really only the beginning.&lt;/p&gt;
</content>
  </entry>
  
  <entry>
    <title>Bridging the System Configuration Gap</title>
    <link href="https://aaronweiss.us/posts/2017-06-05-bridging-the-system-configuration-gap/"/>
    <updated>2017-06-05T00:00:00Z</updated>
    <id>https://aaronweiss.us/posts/2017-06-05-bridging-the-system-configuration-gap/</id>
    <content type="html">&lt;p&gt;Last Friday, I gave a talk at &lt;a href=&quot;http://www.nepls.org/&quot;&gt;NEPLS&lt;/a&gt; on work I did while I was at UMass with &lt;a href=&quot;https://people.cs.umass.edu/~arjun/home/&quot;&gt;Arjun Guha&lt;/a&gt;. You can find the slide deck for the talk &lt;a href=&quot;https://aaronweiss.us/pubs/nepls17.pdf&quot;&gt;here&lt;/a&gt;, but the rest of this post will be a presentation of the same general material.&lt;/p&gt;
&lt;h1&gt;The State of System Configuration&lt;/h1&gt;
&lt;p&gt;In the past, system administrators relied largely on the shell to configure systems within an organization. Systems would either be configured manually on an individual basis, or automatically by scripts written by more enterprising administrators. However, the increased need for computer systems has made this approach generally intractable.&lt;/p&gt;
&lt;p&gt;With the scale of modern computer systems, system configuration has become a pressing technical challenge. Large companies like &lt;a href=&quot;http://redhat.com/&quot;&gt;Red Hat&lt;/a&gt;, &lt;a href=&quot;https://www.oracle.com/&quot;&gt;Oracle&lt;/a&gt;, and &lt;a href=&quot;https://www.google.com/intl/en/about/&quot;&gt;Google&lt;/a&gt; are pouring money into configuration management tools to deal with these complexities. These tools provide powerful, high-level abstractions to make system administration easier, and they&#39;re widely used for this purpose. For example, &lt;a href=&quot;https://puppet.com/&quot;&gt;Puppet&lt;/a&gt; boasts that it&#39;s used by over 33,000 organizations, including 75 of the Fortune 100.&lt;/p&gt;
&lt;p&gt;Still, scripts written in these configuration languages frequently contain bugs, and the shell remains the simplest way to diagnose them. However, after diagnosis, system administrators cannot &lt;strong&gt;fix&lt;/strong&gt; the bugs from the shell as doing so would cause the state of the system to drift from the state specified by the configuration. Thus, in spite of their advantages, configuration management tools force system administrators to give up the simplicity and familiarity of the shell. But is there some way that we can fix this?&lt;/p&gt;
&lt;h1&gt;Bridging the Gap&lt;/h1&gt;
&lt;p&gt;We&#39;ve developed an approach called &lt;em&gt;imperative configuration repair&lt;/em&gt; that uses techniques derived from general program synthesis to allow administrators to use configuration languages and the shell in harmony. With imperative configuration repair, a user can diagnose and repair a configuration bug via the shell and have the changes &lt;strong&gt;automatically&lt;/strong&gt; propagate back to the original configuration. This propagation keeps the configuration in sync with the system, preventing &lt;em&gt;configuration drift&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Imperative configuration repair has a number of important properties that make it particularly useful to system administrators. Firstly, it&#39;s sound, meaning that all the changes made via the shell are preserved. Secondly, it supports configuration maintainability by preserving the structure and abstraction of the configuration. Thirdly, it deals nicely with the possibility of multiple repairs by presenting the user with a list of repairs ranked in a logical fashion. Finally, it works with all existing shells because it relies on known tools for programming monitoring (like &lt;a href=&quot;https://linux.die.net/man/2/ptrace&quot;&gt;ptrace&lt;/a&gt;).&lt;/p&gt;
&lt;h1&gt;A Repair Scenario&lt;/h1&gt;
&lt;p&gt;To get a better idea of what imperative configuration repair actually looks like, let&#39;s step through an example from the perspective of &lt;a href=&quot;http://www.piedpiper.com/&quot;&gt;Pied Piper&lt;/a&gt; using &lt;a href=&quot;https://puppet.com/&quot;&gt;Puppet&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&quot;language-puppet&quot;&gt;&lt;code class=&quot;language-puppet&quot;&gt;package &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&lt;span class=&quot;token double-quoted&quot;&gt;&quot;apache2&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;ensure&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; present &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;service &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&lt;span class=&quot;token double-quoted&quot;&gt;&quot;apache2&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;ensure&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; running &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;website&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token variable&quot;&gt;$title&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token variable&quot;&gt;$root&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;  file &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&lt;span class=&quot;token double-quoted&quot;&gt;&quot;/etc/apache2/sites-enabled/&lt;span class=&quot;token interpolation variable&quot;&gt;$title&lt;/span&gt;.conf&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token attr-name&quot;&gt;content&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&lt;span class=&quot;token double-quoted&quot;&gt;&quot;&amp;lt;VirtualHost &lt;span class=&quot;token interpolation variable&quot;&gt;$title&lt;/span&gt;:80&gt;&lt;br /&gt;    DocumentRoot /var/sites/&lt;span class=&quot;token interpolation variable&quot;&gt;$root&lt;/span&gt;&lt;br /&gt;    &amp;lt;/VirtualHost&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;  file &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&lt;span class=&quot;token double-quoted&quot;&gt;&quot;/var/sites/&lt;span class=&quot;token interpolation variable&quot;&gt;$root&lt;/span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token attr-name&quot;&gt;ensure&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; directory&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token attr-name&quot;&gt;source&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&lt;span class=&quot;token double-quoted&quot;&gt;&quot;puppet://sites/&lt;span class=&quot;token interpolation variable&quot;&gt;$root&lt;/span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token attr-name&quot;&gt;mode&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0700&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token attr-name&quot;&gt;recurse&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&lt;span class=&quot;token double-quoted&quot;&gt;&quot;remote&quot;&lt;/span&gt;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;website &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&lt;span class=&quot;token double-quoted&quot;&gt;&quot;piedpiper.com&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&lt;span class=&quot;token double-quoted&quot;&gt;&quot;piedpiper&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;website &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&lt;span class=&quot;token double-quoted&quot;&gt;&quot;piperchat.com&quot;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&lt;span class=&quot;token double-quoted&quot;&gt;&quot;piperchat&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, we install and start the Apache service. We also create two simple Apache configurations that set up two websites, PiedPiper.com and PiperChat.com. This uses a type of Puppet abstraction known as a &lt;em&gt;define type&lt;/em&gt;, but you can think of this as a simple function.&lt;/p&gt;
&lt;p&gt;On its face, this Puppet configuration (or &lt;em&gt;manifest&lt;/em&gt;) looks to be correct. However, when we deploy the configuration to a machine and try to visit either website, we get an Error 403: Forbidden. In order to debug this issue, we can then head to the shell. Looking at the log files (&lt;code&gt;tail /var/log/apache2/error.log&lt;/code&gt;), we can see a line stating &lt;code&gt;permission denied&lt;/code&gt;. We haven&#39;t set up anything about user access, and so the problem should be one of filesystem permissions. When we run &lt;code&gt;stat /var/sites/piedpiper&lt;/code&gt;, we get back that the owner is &lt;code&gt;root&lt;/code&gt; and the permissions are &lt;code&gt;-rwx------&lt;/code&gt; (or &lt;code&gt;0700&lt;/code&gt; for short). From this, we can recognize the issue: our &lt;code&gt;www&lt;/code&gt; user cannot access the files Apache is trying to serve!&lt;/p&gt;
&lt;p&gt;Now that we&#39;ve identified the issue, we can try to fix it. One possible fix is to run &lt;code&gt;chmod 755 /var/sites/piedpiper&lt;/code&gt;. We can run this in the shell, and then run the special command &lt;code&gt;synth&lt;/code&gt; to start the process of imperative configuration repair. This will automatically propagate the changes back to the manifest, resulting in the mode line changing to &lt;code&gt;mode =&amp;gt; 0755&lt;/code&gt;.&lt;/p&gt;
&lt;h1&gt;Multiple Repairs&lt;/h1&gt;
&lt;p&gt;To get a sense of how multiple repairs are handled with imperative configuration repair, we can look at a simple, but slightly contrived example with a single instantiation of a single abstraction.&lt;/p&gt;
&lt;pre class=&quot;language-puppet&quot;&gt;&lt;code class=&quot;language-puppet&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;dir&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token variable&quot;&gt;$path&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;  file &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token variable&quot;&gt;$path&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token attr-name&quot;&gt;ensure&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; directory&lt;br /&gt;  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;dir &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;token attr-name&quot;&gt;path&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&gt;&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&lt;span class=&quot;token double-quoted&quot;&gt;&quot;/foo&quot;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, we have a &lt;code&gt;dir&lt;/code&gt; abstraction that creates a directory at the specified path, and a single instantiation for the path &lt;code&gt;&amp;quot;/foo&amp;quot;&lt;/code&gt;. If we then use the command &lt;code&gt;mv /foo /bar&lt;/code&gt;, there are actually two possible repairs that make this change. The obvious one changes the constant &lt;code&gt;&amp;quot;/foo&amp;quot;&lt;/code&gt; to &lt;code&gt;&amp;quot;/bar&amp;quot;&lt;/code&gt;, but the other one changes the use of &lt;code&gt;$path&lt;/code&gt; on the second line to &lt;code&gt;&amp;quot;/bar&amp;quot;&lt;/code&gt; meaning the abstraction ignores its parameter.&lt;/p&gt;
&lt;p&gt;Both repairs are correct in that they preserve the changes made via the shell, but a user is likely to prefer the one that changes the parameters to the abstraction. We capture this intuition in a ranking algorithm. We calculate a cost for each repair that corresponds to the sum of the number of updates and the number of updates within an abstraction. This means that smaller updates and updates that make changes outside abstractions are preferred.&lt;/p&gt;
&lt;h1&gt;Bringing the Shell to Puppet&lt;/h1&gt;
&lt;p&gt;We implemented a prototype of imperative configuration repair for Puppet which we called &lt;a href=&quot;https://github.com/plasma-umass/Tortoise&quot;&gt;Tortoise&lt;/a&gt;. Our prototype is written in &lt;a href=&quot;http://scala-lang.org/&quot;&gt;Scala&lt;/a&gt;, and consists of around 3,300 lines of code. It&#39;s built using &lt;a href=&quot;https://linux.die.net/man/1/strace&quot;&gt;strace&lt;/a&gt; and &lt;a href=&quot;http://rise4fun.com/z3&quot;&gt;z3&lt;/a&gt;. It has its limitations, but works on a set of thirteen real Puppet benchmarks from &lt;a href=&quot;https://github.com/&quot;&gt;GitHub&lt;/a&gt; used in prior work. To get a better sense of how it works, let&#39;s step through the whole toolchain at a high level.&lt;/p&gt;
&lt;p&gt;The user starts a Tortoise monitor on a shell using its pid: &lt;code&gt;tortoise watch -i manifest.pp -p pid&lt;/code&gt;. The user must specify which manifest is deployed on the system and should be updated according to the edits made. They then enter a number of commands on the shell which produce file system effects via system calls. Tortoise records these effectful system calls and the paths that they&#39;ve affected. When the user has fixed the bug, they run the command &lt;code&gt;synth&lt;/code&gt; to signal to Tortoise to generate the repair.&lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;https://aaronweiss.us/posts/2017-06-05-bridging-the-system-configuration-gap/#fn1&quot; id=&quot;fnref1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; After receiving the &lt;code&gt;synth&lt;/code&gt; command, the process of imperative configuration repair begins.&lt;/p&gt;
&lt;p&gt;Once initiated, Tortoise starts by parsing the manifest identified by the &lt;code&gt;-i&lt;/code&gt; flag into a Puppet abstract syntax tree (AST). Then, it performs a labeling operation on the AST that assigns a unique label to each variable binding (including in abstractions). These labels are used to associate repairs with their corresponding bindings. We then compile the Puppet manifest into an imperative specification language called ΔP. This ΔP specification captures a series of file system operations and is used to generate a corresponding abstract file system on which the changes recorded by strace can be replayed. After replaying these changes, we can then use the abstract file system to produce ΔP constraints that will be used next in the synthesis procedure.&lt;/p&gt;
&lt;p&gt;The synthesis procedure starts by compiling the ΔP specification into logical formulas describing the step-by-step operation of the manifest over a symbolic file system. It then converts the ΔP constraints into logical assertions about the final state of the program over the symbolic file system. Because these changes were made via the shell after running the program, they may currently be false. Next, &lt;a href=&quot;http://rise4fun.com/z3&quot;&gt;z3&lt;/a&gt; is asked to repeatedly find new models for the repair by replacing values present in the original program. Each of these models are recorded, and parsed into repair substitutions. These repairs are then ranked by the previously described ranking algorithm, and presented to the user. The user then selects their preferred repair, and the system automatically applies it to the manifest on disk.&lt;/p&gt;
&lt;h1&gt;Evaluating Tortoise&lt;/h1&gt;
&lt;p&gt;We evaluated our prototype on a suite of thirteen real world Puppet benchmarks that were gathered from GitHub. These benchmarks consist of instantiations of open source Puppet modules. For each benchmark, we identified a number of possible repairs to make via the shell. We ran Tortoise with each benchmark and each shell repair, and produced a list of repairs. To understand the effectiveness of the ranking procedure, we presented this list in a randomized fashion and asked the user to select their preferred repair. We recorded the Tortoise-assigned rank of this repair for each instance. We then averaged them and found that the average repair rank was 1.31 indicating that Tortoise typically ranks the preferred repair as the first option (this exact case occurred 75% of the time).&lt;/p&gt;
&lt;figure data-type=&quot;image&quot;&gt;&lt;img src=&quot;https://aaronweiss.us/images/size-scaling.png&quot; alt=&quot;Varying manifest size with a constant-sized update.&quot; /&gt;&lt;/figure&gt;
&lt;p&gt;We also looked at evaluating the scalability of Tortoise on artificial benchmarks. In each case, we ran 100 trials at each size, recorded the runtime, and computed the average and confidence interval across all trials. In one case, we looked at varying the size of the manifest while leaving the update size constant. This result is presented above. In practice, most manifests do not seem to grow beyond this size and the performance is well under a second. So, this performance seems reasonable.&lt;/p&gt;
&lt;p&gt;In the other case, we looked at varying the size of the update. This result is presented below, and appears roughly exponential. This is expected because Tortoise relies on SMT solving to generate repairs. Fortunately, we can break up large repairs into a series of smaller intermediate pieces (that cover some part of the overall repair) and avoid the degenerate performance at large sizes. In general, we expect that users will likely perform distinct updates separately anyway.&lt;/p&gt;
&lt;figure data-type=&quot;image&quot;&gt;&lt;img src=&quot;https://aaronweiss.us/images/update-scaling.png&quot; alt=&quot;Varying update size for a manifest.&quot; /&gt;&lt;/figure&gt;
&lt;h1&gt;Summary&lt;/h1&gt;
&lt;p&gt;In conclusion, we presented imperative configuration repair and a prototype &lt;a href=&quot;https://github.com/plasma-umass/Tortoise&quot;&gt;Tortoise&lt;/a&gt; that together bridge the gap between configuration management tools and the shell. Imperative configuration repair preserves all changes made from the shell, preserves the structure and abstractions of the original manifest, and uses instrumentation techniques to support all existing shells. Our prototype implementation is fast, and shows that our ranking algorithm appears reasonable. Overall, we have demonstrated that imperative configuration repair is a realistic technique for improving the process of configuration management.&lt;/p&gt;
&lt;hr class=&quot;footnotes-sep&quot; /&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;ol class=&quot;footnotes-list&quot;&gt;
&lt;li id=&quot;fn1&quot; class=&quot;footnote-item&quot;&gt;&lt;p&gt;Currently, &lt;code&gt;synth&lt;/code&gt; is just an alias of the Unix &lt;code&gt;true&lt;/code&gt;. A future version of Tortoise will instead have a dedicated &lt;code&gt;synth&lt;/code&gt; program that communicates with the Tortoise monitor and presents the choice of repairs in this shell, rather than the monitoring one. &lt;a href=&quot;https://aaronweiss.us/posts/2017-06-05-bridging-the-system-configuration-gap/#fnref1&quot; class=&quot;footnote-backref&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</content>
  </entry>
  
  <entry>
    <title>Reasoning with Types in Rust</title>
    <link href="https://aaronweiss.us/posts/2018-02-26-reasoning-with-types-in-rust/"/>
    <updated>2018-02-26T00:00:00Z</updated>
    <id>https://aaronweiss.us/posts/2018-02-26-reasoning-with-types-in-rust/</id>
    <content type="html">&lt;p&gt;&lt;a href=&quot;https://www.rust-lang.org/&quot;&gt;Rust&lt;/a&gt; is a modern programming language which is marketed primarily on the basis of its very
nice type system, and I&#39;d like to tell you about how you can use this type system to reason about
your programs in interesting ways. Most of the time when its type system is discussed, the focus is
on its guarantee of data race freedom and ability to enable so-called
&lt;a href=&quot;https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html&quot;&gt;&lt;em&gt;fearless concurrency&lt;/em&gt;&lt;/a&gt; (and rightfully so---this is a place where Rust truly shines!).
Today, I have a different focus in mind, characterized perhaps most succinctly as follows:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;From the type of a polymorphic function we can derive a theorem that it satisfies. Every function
of the same type satisfies the same theorem. This provides a free source of useful theorems.&lt;/p&gt;
&lt;p&gt;&lt;cite&gt;Philip Wadler, &lt;a href=&quot;http://ecee.colorado.edu/ecen5533/fall11/reading/free.pdf&quot;&gt;&lt;em&gt;Theorems for Free!&lt;/em&gt;&lt;/a&gt;&lt;/cite&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;If you&#39;re not the most mathematically inclined, don&#39;t be scared off by the word theorem! The quote
is telling us that---with the right property of our type system---we can learn useful properties
about generic (i.e. polymorphic) functions solely by inspecting their types. In the rest of this
post, we&#39;ll cover this type system property, and a number of example properties we can derive from
types as as result.&lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;https://aaronweiss.us/posts/2018-02-26-reasoning-with-types-in-rust/#fn1&quot; id=&quot;fnref1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; Much of what&#39;s covered can be generalized to languages aside from Rust,
but (most) examples will be in Rust with Rust-specific aspects highlighted.&lt;/p&gt;
&lt;h1&gt;A Principal Property for Reasoning&lt;/h1&gt;
&lt;p&gt;The property at the heart of this style of type-based reasoning with generics is known as
&lt;em&gt;parametricity&lt;/em&gt;. Parametricity can be formulated as a mathematical theorem,&lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;https://aaronweiss.us/posts/2018-02-26-reasoning-with-types-in-rust/#fn2&quot; id=&quot;fnref2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt; but it&#39;s best
thought of intuitively as the notion that all instances of a polymorphic function act the same way.
With this intuition in mind, you can imagine determining whether or not a particular function is
parametric. For example, we can determine that the following &lt;a href=&quot;https://www.java.com/&quot;&gt;Java&lt;/a&gt; function is parametric:&lt;/p&gt;
&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;identity&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And that the following Java function is not:&lt;/p&gt;
&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token generics&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;&gt;&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;notIdentity&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x &lt;span class=&quot;token keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The reason for this is that the latter function has chosen to specialize its behavior based on the
type of its parameter, rather than acting the same on all types. This cuts to the essence of
parametricity: to write parametric functions, we must treat parametric types opaquely! While Java
does not enforce parametricity (and in fact often encourages otherwise), other type systems like that
of &lt;a href=&quot;https://www.haskell.org/&quot;&gt;Haskell&lt;/a&gt; and Rust require all functions to be parametric.&lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;https://aaronweiss.us/posts/2018-02-26-reasoning-with-types-in-rust/#fn3&quot; id=&quot;fnref3&quot;&gt;[3]&lt;/a&gt;&lt;/sup&gt; When all polymorphic
functions are parametric, the type system is said to be &lt;em&gt;parametrically polymorphic&lt;/em&gt;---though in
practice, many parametrically polymorphic type systems support some degree of ad hoc (that is,
type-dependent polymorphism). In this case, we know that all polymorphic functions are parametric
and we&#39;re able to learn some of their properties solely from their type. So, let&#39;s look at some
examples in Rust.&lt;/p&gt;
&lt;h1&gt;Who am I? or: Reasoning about Identity&lt;/h1&gt;
&lt;p&gt;Consider the following function type, and try to imagine as many implementations as possible:&lt;/p&gt;
&lt;pre class=&quot;language-rust&quot;&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;-&gt;&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This type describes a function that for any type &lt;code&gt;T&lt;/code&gt;, takes an argument of type &lt;code&gt;T&lt;/code&gt;
and returns a result of type &lt;code&gt;T&lt;/code&gt;. If you&#39;re already familiar with Rust, I&#39;m sure it wouldn&#39;t
take long to come up with the following implementation, the identity function:&lt;/p&gt;
&lt;pre class=&quot;language-rust&quot;&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;token function-definition function&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;-&gt;&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    x&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In fact, since there are no operations we can actually perform on &lt;code&gt;x&lt;/code&gt;, it&#39;s the only possible
return value for this function. Of course, since Rust is effectful, we could print something before
we return like so:&lt;/p&gt;
&lt;pre class=&quot;language-rust&quot;&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;token function-definition function&quot;&gt;effectful_id&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;-&gt;&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token macro property&quot;&gt;println!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;oh no&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    x&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And Rust is also partial, meaning we could error (called &lt;em&gt;panicking&lt;/em&gt; in Rust) or otherwise diverge:&lt;/p&gt;
&lt;pre class=&quot;language-rust&quot;&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;token function-definition function&quot;&gt;panicking_id&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;_&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;-&gt;&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token macro property&quot;&gt;panic!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;at the disco&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;token function-definition function&quot;&gt;diverging_id&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;_&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;-&gt;&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;loop&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These various implementations all tell us something about what the type means, which we can phrase
like so:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A function of type &lt;code&gt;fn&amp;lt;T&amp;gt;(T) -&amp;gt; T&lt;/code&gt; must:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;return its argument &lt;strong&gt;or&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;panic or abort &lt;strong&gt;or&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;never return&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;Additionally, since we still know nothing about the type &lt;code&gt;T&lt;/code&gt;, we can conclude that any
effects that occur during the function are &lt;em&gt;not&lt;/em&gt; dependent on the argument. With these two
properties, we can then conclude the more general properties that functions of the type
&lt;code&gt;fn&amp;lt;T&amp;gt;(T) -&amp;gt; T&lt;/code&gt; behave &amp;quot;like an identity function&amp;quot;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Given a function &lt;code&gt;id&lt;/code&gt; of type &lt;code&gt;fn&amp;lt;T&amp;gt;(T) -&amp;gt; T&lt;/code&gt;, a total function &lt;code&gt;f&lt;/code&gt; of the
form &lt;code&gt;fn(A) -&amp;gt; B&lt;/code&gt; where &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are both concrete types, and a value
&lt;code&gt;a&lt;/code&gt; of type &lt;code&gt;A&lt;/code&gt;, then either:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;id&lt;/code&gt; can be composed arbitrarily (e.g. &lt;code&gt;id(f(a)) = f(id(a))&lt;/code&gt;) &lt;strong&gt;or&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;id(f(a))&lt;/code&gt; and &lt;code&gt;f(id(a))&lt;/code&gt; both panic or diverge.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;In order to conclude this, we can consider each of the cases we previously described. If the
function returns its argument, then we know both that &lt;code&gt;id(a) = a&lt;/code&gt; and
&lt;code&gt;id(f(a)) = f(a)&lt;/code&gt; and we can combine these two equalities to conclude the first result. If
the function does not return its arguments, we know it either panics or never returns but we also
know that this cannot be dependent on the argument in any way. Thus if &lt;code&gt;id(f(a))&lt;/code&gt; panics,
then &lt;code&gt;f(id(a))&lt;/code&gt; &lt;strong&gt;must&lt;/strong&gt; panic as well.&lt;/p&gt;
&lt;p&gt;With that, we&#39;ve intuited (but have not formally proven)&lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;https://aaronweiss.us/posts/2018-02-26-reasoning-with-types-in-rust/#fn4&quot; id=&quot;fnref4&quot;&gt;[4]&lt;/a&gt;&lt;/sup&gt; our first &amp;quot;useful theorem&amp;quot; about
a family of functions based solely on their type. While it&#39;s nice to know that identity-looking
functions behave like an identity function, there&#39;s certainly nothing earth-shattering about the
result. But the fact that we can apply this style of reasoning to &lt;em&gt;every&lt;/em&gt; type ought to be
compelling.&lt;/p&gt;
&lt;h1&gt;Vectors Abound&lt;/h1&gt;
&lt;p&gt;Let&#39;s look at a slightly more complicated type now, involving Rust&#39;s &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; type for
dynamically-sized buffers. We&#39;ll again follow the same formula of enumerating some possible
implementations before trying to conclude a general property. Given the type:&lt;/p&gt;
&lt;pre class=&quot;language-rust&quot;&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;-&gt;&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can come up with implementations such as:&lt;/p&gt;
&lt;pre class=&quot;language-rust&quot;&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;token function-definition function&quot;&gt;tail&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;vec&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;-&gt;&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    vec&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;into_iter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;skip&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;collect&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;token function-definition function&quot;&gt;reverse&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;vec&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;-&gt;&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; init &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;with_capacity&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;vec&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;capacity&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    vec&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;into_iter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;fold&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;init&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token closure-params&quot;&gt;&lt;span class=&quot;token closure-punctuation punctuation&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;mut&lt;/span&gt; acc&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; elem&lt;span class=&quot;token closure-punctuation punctuation&quot;&gt;|&lt;/span&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        acc&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; elem&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;        acc&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;token function-definition function&quot;&gt;swap_first_two&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;mut&lt;/span&gt; vec&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;-&gt;&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Vec&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; vec&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; vec&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; elem &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; vec&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;remove&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    vec&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; elem&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    vec&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can then try to capture a sense of what this type means as we did before:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A function &lt;code&gt;m&lt;/code&gt; (for mystery) of type &lt;code&gt;fn&amp;lt;T&amp;gt;(Vec&amp;lt;T&amp;gt;) -&amp;gt; Vec&amp;lt;T&amp;gt;&lt;/code&gt; must:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;return a &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; that contains a subset of the contents of its argument
&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; in any order. (i.e. &lt;code&gt;∀v. {e | e ∈ m(v)} ⊆ {e | e ∈ v}&lt;/code&gt;) &lt;strong&gt;or&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;panic or abort &lt;strong&gt;or&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;never return&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;The process of concluding this is more complicated, but the general gist is that such a function can
only perform the operations defined on &lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/code&gt; and as usual cannot inspect the types of its
elements. From there, we know that we cannot create new values of type &lt;code&gt;T&lt;/code&gt; or perform any
operations dependent on values within the vector. This also leverages the Rust-specific fact that
values (in this case, of type &lt;code&gt;T&lt;/code&gt;) cannot be copied without knowing that they implement
&lt;code&gt;Clone&lt;/code&gt; and/or &lt;code&gt;Copy&lt;/code&gt; (whereas in other languages with parametricity, this typically
is not the case). We can then conclude that all functions at this type must yield a permutation (or
possibly a subset of a permutation) of the input vector. Of course, the same exceptions about panics
and divergence apply. Interestingly, we can reach a similar general conclusion to the one we reached
for &lt;code&gt;fn&amp;lt;T&amp;gt;(T) -&amp;gt; T&lt;/code&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Given a function &lt;code&gt;m&lt;/code&gt; of type &lt;code&gt;fn&amp;lt;T&amp;gt;(Vec&amp;lt;T&amp;gt;) -&amp;gt; Vec&amp;lt;T&amp;gt;&lt;/code&gt;, a total function &lt;code&gt;f&lt;/code&gt;
of the form &lt;code&gt;fn(A) -&amp;gt; B&lt;/code&gt; where &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are both concrete types, and
&lt;code&gt;a&lt;/code&gt; is a value of type &lt;code&gt;Vec&amp;lt;A&amp;gt;&lt;/code&gt;, then either:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mystery(map_f(a)) = map_f(mystery(a))&lt;/code&gt; where &lt;code&gt;map_f&lt;/code&gt; is defined as
&lt;code&gt;|x| { x.iter().map(f).collect() }&lt;/code&gt; &lt;strong&gt;or&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;at least one of &lt;code&gt;mystery(map_f(a))&lt;/code&gt; and &lt;code&gt;map_f(mystery(a))&lt;/code&gt; panic or diverge.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h1&gt;Noninterference for Free&lt;/h1&gt;
&lt;p&gt;Thus far, we&#39;ve looked at rather simple properties of programs because it is easier to imagine the
proof in your head. But now, let&#39;s take the opportunity to explore a security property called
&lt;em&gt;noninterference&lt;/em&gt; for which a number of tailored type systems have been built. The idea behind these
type systems is typically that you annotate types and values in your program with labels indicating
whether a value should be public or secret (some systems expand this with further labels, but just
the two are enough for the basics). Noninterference then says that functions with public output
cannot depend on private inputs. Fortunately, using parametricity, we can have this property for
free in Rust!&lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;https://aaronweiss.us/posts/2018-02-26-reasoning-with-types-in-rust/#fn5&quot; id=&quot;fnref5&quot;&gt;[5]&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;To do so, first, we have to define a notion of secret (we&#39;ll treat all unannotated types as
public, though we could choose to introduce a public type as well for symmetry):&lt;/p&gt;
&lt;pre class=&quot;language-rust&quot;&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token type-definition class-name&quot;&gt;Secret&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Strictly speaking, we&#39;ve now achieved noninterference! That was probably easier than you expected,
but the intuition should be clear: since we can perform no operations whatsoever on values of the
type &lt;code&gt;Secret&amp;lt;T&amp;gt;&lt;/code&gt;, it is impossible for public outputs to depend on secret data! However,
there is a caveat: because of how access modifiers work in Rust, code in the same module can violate
noninterference like so:&lt;/p&gt;
&lt;pre class=&quot;language-rust&quot;&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token type-definition class-name&quot;&gt;Secret&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;token function-definition function&quot;&gt;unwrap_secret&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;secret&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Secret&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;-&gt;&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    secret&lt;span class=&quot;token number&quot;&gt;.0&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To avoid this, we can place our implementation of secret types inside of its own module with no
additional code:&lt;/p&gt;
&lt;pre class=&quot;language-rust&quot;&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;mod&lt;/span&gt; &lt;span class=&quot;token module-declaration namespace&quot;&gt;secret&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token type-definition class-name&quot;&gt;Secret&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;token module-declaration namespace&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;::&lt;/span&gt;secret&lt;span class=&quot;token punctuation&quot;&gt;::&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Secret&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, we have noninterference enforced in any downstream code, but in real security type systems, you
can still use secret values to compute other secret values. To do this, we can use Rust&#39;s trait
system to add common functionality. We can use this to define a lot of operations, but some of the
operator-overloading traits (&lt;code&gt;std::ops&lt;/code&gt;) are not currently general enough making some code
less pleasant.&lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;https://aaronweiss.us/posts/2018-02-26-reasoning-with-types-in-rust/#fn6&quot; id=&quot;fnref6&quot;&gt;[6]&lt;/a&gt;&lt;/sup&gt; Here is our example with some ability to use secret values to compute other
secret values:&lt;/p&gt;
&lt;pre class=&quot;language-rust&quot;&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;mod&lt;/span&gt; &lt;span class=&quot;token module-declaration namespace&quot;&gt;secret&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token attribute attr-name&quot;&gt;#[derive(Copy, Clone, Default)]&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token type-definition class-name&quot;&gt;Secret&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;token namespace&quot;&gt;std&lt;span class=&quot;token punctuation&quot;&gt;::&lt;/span&gt;ops&lt;span class=&quot;token punctuation&quot;&gt;::&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Sub&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Add&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Secret&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Add&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;token type-definition class-name&quot;&gt;Output&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Secret&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;token function-definition function&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; other&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Secret&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;-&gt;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;Self&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Output&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token class-name&quot;&gt;Secret&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; other&lt;span class=&quot;token number&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Sub&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Secret&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Sub&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;token type-definition class-name&quot;&gt;Output&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Secret&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Sub&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Output&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;token function-definition function&quot;&gt;sub&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; other&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Secret&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;-&gt;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;Self&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Output&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token class-name&quot;&gt;Secret&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt; other&lt;span class=&quot;token number&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;    &lt;span class=&quot;token comment&quot;&gt;// ...&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;token module-declaration namespace&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;::&lt;/span&gt;secret&lt;span class=&quot;token punctuation&quot;&gt;::&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Secret&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, we have some ways of using our secret data to construct other secret data. It&#39;s limited, but
many other extensions should follow similar patterns and we could also add other operations
implemented directly on &lt;code&gt;Secret&amp;lt;T&amp;gt;&lt;/code&gt; types that compose secret values without going through a
trait like so:&lt;/p&gt;
&lt;pre class=&quot;language-rust&quot;&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Secret&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;token function-definition function&quot;&gt;branch&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; cons&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; alt&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;-&gt;&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Secret&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;F&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Fn&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;-&gt;&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Secret&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token function&quot;&gt;cons&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;            &lt;span class=&quot;token function&quot;&gt;alt&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With all these extensions, the argument that parametricity is still enforcing noninterference is now
dependent on the exact set of operations that have been implemented for &lt;code&gt;Secret&amp;lt;T&amp;gt;&lt;/code&gt;, but as
long as they &lt;em&gt;always&lt;/em&gt; return an argument of the form &lt;code&gt;Secret&amp;lt;T&amp;gt;&lt;/code&gt;, Rust will enforce
noninterference. We can even include operations that combine &lt;code&gt;Secret&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;T&lt;/code&gt; as
long as their results are themselves secret. We could even imagine building a simple static analysis
tool that runs atop Rust to audit a crate providing such a secret type to ensure that every function
it implements returns a secret marked type.&lt;/p&gt;
&lt;h1&gt;Bountiful Properties with Bounded Parametricity&lt;/h1&gt;
&lt;p&gt;Though we used traits to extend the functionality of our &lt;code&gt;Secret&amp;lt;T&amp;gt;&lt;/code&gt; type, they played a
somewhat limited role in our argument for noninterference via parametricity, but we can do more.
Fundamentally, traits allow us to bound type parameters with a specific interface that can be used
within functions. This allow us to weaken our notion of parametricity from type parameters and
values at those types being completely opaque to values at those types being usable in a controlled
fashion. Correspondingly, we can derive even more interesting properties from the types. For a
simple example, consider this extended version of our original identity example:&lt;/p&gt;
&lt;pre class=&quot;language-rust&quot;&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;-&gt;&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Display&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Previously, we said that any side-effects of this function could not depend on the argument. By
adding the &lt;code&gt;Display&lt;/code&gt; bound on &lt;code&gt;T&lt;/code&gt;, we&#39;ve allowed the argument to be displayed in
output effects like &lt;code&gt;println!&lt;/code&gt;. In a sense, this new ability to display the argument is
expanding the allowed set of side-effects. This expansion is most evident from the fact that all of
our old implementations are still legal at this bounded type, but new implementations are also
legal. For example:&lt;/p&gt;
&lt;pre class=&quot;language-rust&quot;&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;token function-definition function&quot;&gt;trace&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;-&gt;&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Display&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token macro property&quot;&gt;println!&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&quot;{}&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    x&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You may have noticed as we went through our earlier noninterference example that this property seems
almost useless by virtue of being overly strict. In particular, since public outputs cannot depend
on secret values in any way, there&#39;s really no reason to use secret values at all. In practice,
security type systems offer escape hatches (much like Rust&#39;s &lt;code&gt;unsafe&lt;/code&gt;) to selectively reveal
secret information in a way that is readily auditable. With traits, we can build a principled escape
hatch giving us a weakened property known as &lt;em&gt;relaxed noninterference&lt;/em&gt;.&lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;https://aaronweiss.us/posts/2018-02-26-reasoning-with-types-in-rust/#fn7&quot; id=&quot;fnref7&quot;&gt;[7]&lt;/a&gt;&lt;/sup&gt; Relaxed noninterference
can be understood intuitively as the property that public outputs can only depend on secret values
according to predetermined rules known as &lt;em&gt;declassification policies&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;In our formulation in Rust, we will record these policies as traits and use trait bounds to decide
what policies are available within a function. Consequently, the type signatures of our functions
will necessarily have to tell us how they plan on using the secret data we give them giving us
strong, local reasoning principles for security. At the heart of this approach is our previous
definition of &lt;code&gt;Secret&amp;lt;T&amp;gt;&lt;/code&gt; with a trait representing the empty declassification policy:&lt;/p&gt;
&lt;pre class=&quot;language-rust&quot;&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token type-definition class-name&quot;&gt;Secret&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;token type-definition class-name&quot;&gt;Sec&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token namespace&quot;&gt;private&lt;span class=&quot;token punctuation&quot;&gt;::&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Sealed&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Sec&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Secret&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;mod&lt;/span&gt; &lt;span class=&quot;token module-declaration namespace&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;Secret&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;token type-definition class-name&quot;&gt;Sealed&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Sealed&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Secret&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our private module here is used to seal the &lt;code&gt;Sec&amp;lt;T&amp;gt;&lt;/code&gt; trait preventing it from being
implemented on any additional types beyond &lt;code&gt;Secret&amp;lt;T&amp;gt;&lt;/code&gt;. With just this, we can now specify
functions like before that have noninterference:&lt;/p&gt;
&lt;pre class=&quot;language-rust&quot;&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;token function-definition function&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;u32&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; y&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;-&gt;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;u32&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Sec&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;u32&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token comment&quot;&gt;// the following line is not legal...&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token comment&quot;&gt;// return y.0;&lt;/span&gt;&lt;br /&gt;    x&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can then specify a number of declassification policies that enable us to make selective use of
our secret values:&lt;/p&gt;
&lt;pre class=&quot;language-rust&quot;&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;token comment&quot;&gt;// Debug declassification policy: can format the value for debugging purposes&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Debug&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Secret&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Debug&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;token function-definition function&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; f&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Formatter&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;-&gt;&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Result&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Error&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;fmt&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;f&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;// Zeroable declassification policy: can determine whether or not this is zero&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Zeroable&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Secret&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Zeroable&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;token function-definition function&quot;&gt;is_zero&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;-&gt;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;is_zero&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;span class=&quot;token comment&quot;&gt;// Hash declassification policy: can compute a hash of the value&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;impl&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Hash&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Secret&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Hash&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;token function-definition function&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;H&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; state&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;H&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;H&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Hasher&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;        &lt;span class=&quot;token keyword&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;state&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And then we can use these declassification policies to discern legal implementations of specific
types as we&#39;ve done before. Consider the type:&lt;/p&gt;
&lt;pre class=&quot;language-rust&quot;&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token lifetime-annotation symbol&quot;&gt;&#39;a&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;u64&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;-&gt;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Sec&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;token lifetime-annotation symbol&quot;&gt;&#39;a&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Hash&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We know that there are some trivial implementations (e.g. comparing the &lt;code&gt;u64&lt;/code&gt; against
&lt;code&gt;0&lt;/code&gt;) that don&#39;t make use of the secret value, but what about implementations that do? We can
come up with something like:&lt;/p&gt;
&lt;pre class=&quot;language-rust&quot;&gt;&lt;code class=&quot;language-rust&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;pub&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;token function-definition function&quot;&gt;check&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token lifetime-annotation symbol&quot;&gt;&#39;a&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;password&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; db_hash&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;u64&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;-&gt;&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;bool&lt;/span&gt;&lt;br /&gt;&lt;span class=&quot;token keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;S&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Sec&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;token lifetime-annotation symbol&quot;&gt;&#39;a&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&gt;&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Hash&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token comment&quot;&gt;// please don&#39;t actually do this, use bcrypt or scrypt instead.&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;token namespace&quot;&gt;std&lt;span class=&quot;token punctuation&quot;&gt;::&lt;/span&gt;collections&lt;span class=&quot;token punctuation&quot;&gt;::&lt;/span&gt;hash_map&lt;span class=&quot;token punctuation&quot;&gt;::&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;DefaultHasher&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;mut&lt;/span&gt; hasher &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;DefaultHasher&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    password&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;mut&lt;/span&gt; hasher&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;    hasher&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;finish&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; db_hash&lt;br /&gt;&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, if we connected this to a web framework (like the amazing &lt;a href=&quot;https://rocket.rs/&quot;&gt;Rocket&lt;/a&gt;), we could imagine
having our forms always providing passwords as secret values. Then, by using traits as
declassification policies, we can use the type system to ensure that we never accidentally misuse
the password. However, we should be wary: we used &lt;code&gt;Hash&lt;/code&gt; in this example because it&#39;s
provided by &lt;code&gt;std&lt;/code&gt; and includes already-implemented hash algorithms, but it&#39;s actually
overly-permissive for this purpose. We could write a custom hasher that would allow us to leak
information or even completely reveal the value. For a real implementation, we would instead provide
a more constrained trait that allows you to compute a specific cryptographic hash such as bcrypt or
scrypt.&lt;/p&gt;
&lt;h1&gt;Some Final Words&lt;/h1&gt;
&lt;p&gt;If you&#39;ve made it this far, you&#39;ve seen a bunch of &amp;quot;crazy academic concepts&amp;quot; like parametricity,
free theorems, and noninterference. You&#39;ve also seen how traits can be used to relax parametricity
and give us even more useful free theorems. Hopefully, this endeavor has convinced you of the
strength of type-based reasoning in Rust. The &lt;a href=&quot;https://github.com/aatxe/reasoning-with-types&quot;&gt;small examples&lt;/a&gt; that you&#39;ve seen
throughout the post are really just scratching the surface of this kind of reasoning: we can go
further by using the added constraints from the ownership system to produce even more interesting
theorems (such as that a &lt;a href=&quot;https://en.wikipedia.org/wiki/Cryptographic_nonce&quot;&gt;cryptographic nonce&lt;/a&gt; is only used once). The extent of these
reasoning capabilities is one of my personal favorite features of strong type systems, and
subsequently one of my favorite things about Rust. Maybe it&#39;ll be one of yours now too!&lt;/p&gt;
&lt;hr class=&quot;footnotes-sep&quot; /&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;ol class=&quot;footnotes-list&quot;&gt;
&lt;li id=&quot;fn1&quot; class=&quot;footnote-item&quot;&gt;&lt;p&gt;Owing to their presentation in the paper &lt;a href=&quot;http://ecee.colorado.edu/ecen5533/fall11/reading/free.pdf&quot;&gt;&lt;em&gt;Theorems for Free!&lt;/em&gt;&lt;/a&gt;, these properties are
known in the  academic world as &lt;em&gt;free theorems&lt;/em&gt;---though I suspect that some will be unhappy with my
liberal application of this term to intuited properties. &lt;a href=&quot;https://aaronweiss.us/posts/2018-02-26-reasoning-with-types-in-rust/#fnref1&quot; class=&quot;footnote-backref&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn2&quot; class=&quot;footnote-item&quot;&gt;&lt;p&gt;And indeed, it was originally presented as the &lt;em&gt;abstraction theorem&lt;/em&gt; in John C. Reynolds&#39;
&lt;a href=&quot;https://commie.club/papers/reynolds83:parametricity.pdf&quot;&gt;&lt;em&gt;Types, abstraction, and parametric polymorphism&lt;/em&gt;&lt;/a&gt;. &lt;a href=&quot;https://aaronweiss.us/posts/2018-02-26-reasoning-with-types-in-rust/#fnref2&quot; class=&quot;footnote-backref&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn3&quot; class=&quot;footnote-item&quot;&gt;&lt;p&gt;Strictly speaking, &lt;a href=&quot;https://cs.appstate.edu/~johannp/popl04.pdf&quot;&gt;Haskell&#39;s &lt;code&gt;seq&lt;/code&gt; breaks general parametricity&lt;/a&gt;, as do Rust&#39;s
various reflection capabilities (including &lt;code&gt;Sized&lt;/code&gt;) and the upcoming
&lt;a href=&quot;https://github.com/rust-lang/rfcs/pull/1210&quot;&gt;impl specialization&lt;/a&gt; feature. Fortunately, like in the Haskell paper, we can always
refine our notion of parametricity. Though this does have some consequences for precisely what
properties you can glean from types. &lt;a href=&quot;https://aaronweiss.us/posts/2018-02-26-reasoning-with-types-in-rust/#fnref3&quot; class=&quot;footnote-backref&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn4&quot; class=&quot;footnote-item&quot;&gt;&lt;p&gt;Though our argument is somewhat proofy, we would require a formal semantics for Rust. There
exists one in the form of &lt;a href=&quot;http://plv.mpi-sws.org/rustbelt/&quot;&gt;RustBelt&lt;/a&gt;, and as part of my research, I hope to produce an
alternative formal backing for these free theorems in Rust, particularly the latter ones related to
security. &lt;a href=&quot;https://aaronweiss.us/posts/2018-02-26-reasoning-with-types-in-rust/#fnref4&quot; class=&quot;footnote-backref&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn5&quot; class=&quot;footnote-item&quot;&gt;&lt;p&gt;A connection between parametricity and noninterference was commonly held wisdom in the
programming languages community, but was not proven until Bowman and Ahmed&#39;s
&lt;a href=&quot;http://www.ccs.neu.edu/home/amal/papers/nifree.pdf&quot;&gt;&lt;em&gt;Noninterference for Free&lt;/em&gt;&lt;/a&gt;. &lt;a href=&quot;https://aaronweiss.us/posts/2018-02-26-reasoning-with-types-in-rust/#fnref5&quot; class=&quot;footnote-backref&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn6&quot; class=&quot;footnote-item&quot;&gt;&lt;p&gt;The consequence of this is that we would need to define methods instead of operators which
would make secret code look weirder and be less ergonomic, but is not a fundamental limitation to
this approach. If the trait definitions were made more general, this would be a nonissue, and we
could use macros instead to offer some improvements. &lt;a href=&quot;https://aaronweiss.us/posts/2018-02-26-reasoning-with-types-in-rust/#fnref6&quot; class=&quot;footnote-backref&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn7&quot; class=&quot;footnote-item&quot;&gt;&lt;p&gt;In &lt;a href=&quot;https://hal.archives-ouvertes.fr/hal-01637023/document&quot;&gt;&lt;em&gt;Type Abstraction for Relaxed Noninterference&lt;/em&gt;&lt;/a&gt;, we see a related presentation
of relaxed noninterference as a consequence of object-oriented type abstraction capabilities. Since
Rust uses parametric polymorphism with traits for type abstraction, we are developing an analogue
here. &lt;a href=&quot;https://aaronweiss.us/posts/2018-02-26-reasoning-with-types-in-rust/#fnref7&quot; class=&quot;footnote-backref&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</content>
  </entry>
  
  <entry>
    <title>T&#39;is the (Grad Apps) Season</title>
    <link href="https://aaronweiss.us/posts/2018-10-01-grad-app-season/"/>
    <updated>2018-10-01T00:00:00Z</updated>
    <id>https://aaronweiss.us/posts/2018-10-01-grad-app-season/</id>
    <content type="html">&lt;p&gt;Yesterday on Twitter, &lt;a href=&quot;http://cattheory.com/&quot;&gt;Joomy Korkut&lt;/a&gt; (&lt;a href=&quot;https://twitter.com/cattheory&quot;&gt;@cattheory&lt;/a&gt;) posted about the graduate
program application season starting again and offered his help to folks who plan to apply. This, of
course, reminded me that I completely dropped the ball on doing the same thing last year as I had
initially intended. So, better late than never: I&#39;m writing this post to share some of my
application materials, and some links to resources I found particularly helpful while I was
applying. I don&#39;t think I otherwise have a ton of profound insight on the topic though, so I&#39;m sorry
if it&#39;s light on my own advice! If you don&#39;t want to read the bits that I&#39;ve written, you can skip
to the very end for a big list of my own materials.&lt;/p&gt;
&lt;h1&gt;Personal Statement&lt;/h1&gt;
&lt;p&gt;I&#39;m not sure to what extent the personal statement was impactful for admissions, but I know that at
least at Northeastern, there was one part of it that was influential. In one section, I called out a
project that I worked on for the graduate PL seminar I was in as an undergrad. The project was to
implement a baby version of Daan Leijen&#39;s &lt;a href=&quot;https://www.microsoft.com/en-us/research/project/koka/&quot;&gt;Koka&lt;/a&gt; that I called &lt;a href=&quot;https://github.com/aatxe/diet-coke&quot;&gt;diet-coke&lt;/a&gt;. Amal
later told me that this information was useful as an indicator of the kinds of things I was
interested in when left to my own devices (since I picked that project &lt;em&gt;without&lt;/em&gt; the advice of my
undergraduate advisor, Arjun). In this post, I&#39;m including my &lt;a href=&quot;https://aaronweiss.us/gradapps/Aaron-Weiss-neu-sop.pdf&quot;&gt;statement of purpose&lt;/a&gt; from
Northeastern, but you should note that they asked for a one-pager which is quite cut-down relative
to the original generic draft (which seems potentially lost to the annals of time).&lt;/p&gt;
&lt;h1&gt;NSF Graduate Research Fellowship&lt;/h1&gt;
&lt;p&gt;The NSF Graduate Research Fellowship is a competitive five-year fellowship (that actually only funds
three years) available to American citizens. I applied as a senior undergrad along with my graduate
school applications, and ultimately won the fellowship. I read a bunch of different resources to try
to get help with this including posts from &lt;a href=&quot;https://jxyzabc.blogspot.com/2008/08/cs-grad-school-part-3-fellowships.html&quot;&gt;Jean Yang&lt;/a&gt;, &lt;a href=&quot;http://www.pgbovine.net/fellowship-tips.htm&quot;&gt;Philip Guo&lt;/a&gt;,
&lt;a href=&quot;http://ltse1.bol.ucla.edu/nsf.html&quot;&gt;Louis Tse&lt;/a&gt;, and &lt;a href=&quot;http://www.malloryladd.com/nsf-grfp-advice.html&quot;&gt;Mallory Ladd&lt;/a&gt;. The last post from Mallory Ladd was the one that I
personally found the most useful when I was applying since it features a large number of distinct
applications, many of which are recent and thus &lt;em&gt;after&lt;/em&gt; the 2014 format change. In this post, I&#39;m
including my &lt;a href=&quot;https://aaronweiss.us/gradapps/Aaron-Weiss-grfp-personal-statement.pdf&quot;&gt;personal statement&lt;/a&gt;, my &lt;a href=&quot;https://aaronweiss.us/gradapps/Aaron-Weiss-grfp-research-proposal.pdf&quot;&gt;research proposal&lt;/a&gt;, and the
&lt;a href=&quot;https://aaronweiss.us/gradapps/Aaron-Weiss-grfp-reviews.pdf&quot;&gt;reviews I received&lt;/a&gt;. I think the big takeaway I got from reading lots of examples was
to explicitly label both &lt;em&gt;Broader Impacts&lt;/em&gt; and &lt;em&gt;Intellectual Merit&lt;/em&gt;. I&#39;m not sure if it was actually
helpful, but reviewers have lots of things competing for their time, and the labeling definitely
makes their lives easier. If you read the reviews, you might note that some of the stuff is almost
copypasta from my submissions.&lt;/p&gt;
&lt;h1&gt;Miscellany&lt;/h1&gt;
&lt;p&gt;There&#39;s also some other stuff that I thought about a lot around the time of my applications. For
example, I had a letter of recommendation from a coworker from a startup with no academic
experience, and another from a professor who I knew fairly well but did not do research with. I
pointed the former to this &lt;a href=&quot;http://cs.brown.edu/~sk/Memos/Grad-School-Recos/&quot;&gt;excellent post&lt;/a&gt; from Shriram Krishnamurthi about letters of
recommendation. The latter I gave this &lt;a href=&quot;https://aaronweiss.us/gradapps/Aaron-Weiss-rec-summary.pdf&quot;&gt;little note&lt;/a&gt; (inspired by Shriram&#39;s post)
summarizing some of the things that I thought were important for admissions. Once I went off to
visit days, I also had a couple of important questions that I asked potential advisors to try to
help make my decisions. Fortunately, I stumbled on the ones that I sent to Amal via email (others
were asked verbally) including an annotation about one particular question that I wrote at the time.
You can find those questions in &lt;a href=&quot;https://aaronweiss.us/gradapps/Aaron-Weiss-questions-to-amal.pdf&quot;&gt;this PDF&lt;/a&gt;.&lt;/p&gt;
&lt;h1&gt;Afterward&lt;/h1&gt;
&lt;p&gt;Once you&#39;re done applying, you&#39;ll probably get a slight reprieve before you just start getting
excited about hearing back from various places. From what I can tell, US schools keep notifying
students earlier and earlier each year, but don&#39;t sweat it if some places take a while. In my case,
Northeastern was the &lt;em&gt;first&lt;/em&gt; school where I spoke with faculty, but actually the &lt;em&gt;last&lt;/em&gt; school to
admit me. Good luck, folks!&lt;/p&gt;
&lt;h1&gt;The Big List of My Stuff&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://aaronweiss.us/gradapps/Aaron-Weiss-neu-sop.pdf&quot;&gt;Northeastern University &lt;em&gt;Statement of Purpose&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://aaronweiss.us/gradapps/Aaron-Weiss-grfp-personal-statement.pdf&quot;&gt;NSF GRFP &lt;em&gt;Personal Statement&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://aaronweiss.us/gradapps/Aaron-Weiss-grfp-research-proposal.pdf&quot;&gt;NSF GRFP &lt;em&gt;Research Proposal&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://aaronweiss.us/gradapps/Aaron-Weiss-grfp-reviews.pdf&quot;&gt;NSF GRFP &lt;em&gt;Reviews&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://aaronweiss.us/gradapps/Aaron-Weiss-rec-summary.pdf&quot;&gt;&lt;em&gt;Personal Summary&lt;/em&gt; for Letter Writer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://aaronweiss.us/gradapps/Aaron-Weiss-questions-to-amal.pdf&quot;&gt;&lt;em&gt;Questions to Amal&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  
  <entry>
    <title>Monty PL and the Holy Grail</title>
    <link href="https://aaronweiss.us/posts/2020-01-27-monty-pl-and-the-holy-grail/"/>
    <updated>2020-01-27T00:00:00Z</updated>
    <id>https://aaronweiss.us/posts/2020-01-27-monty-pl-and-the-holy-grail/</id>
    <content type="html">&lt;p&gt;Conventional wisdom among programmers holds that one should choose &amp;quot;the best
language for the job.&amp;quot; Though exactly which language is &amp;quot;best&amp;quot; is often
ambiguous, in practice, there has arisen a division between so-called
&lt;em&gt;&amp;quot;systems programming&amp;quot;&lt;/em&gt; languages that enable fine-grained control over
the usage and layout of memory, and &lt;em&gt;&amp;quot;applications programming&amp;quot;&lt;/em&gt;
languages that provide the programmer with high-level abstractions to make
correct software more quickly and with less effort. But in the lands of myths
and legends, brave knights of programming languages research seek out the Holy
Grail --- a general-purpose programming language that enables programmers to get
both the high-level abstractions of the latter and the fine-grained control of
the former.&lt;/p&gt;
&lt;h1&gt;The Quest for the Holy Grail&lt;/h1&gt;
&lt;p&gt;For decades, these Knights of PL have explored idea after idea in search of the
grail. One of the most promising discoveries on this quest came as Ser Girard&#39;s
Linear Logic whose powers of reasoning about &lt;em&gt;resources&lt;/em&gt; spawned a wealth of new
work on high-level support for resource management in programming. Among these,
the efforts of Ser Baker on Linear Lisp are most relevant to our tale. On
their quest, Ser Baker used a notion of &lt;em&gt;linearity&lt;/em&gt; to enable efficient
reuse of objects in memory in a functional programming language &lt;em&gt;without&lt;/em&gt;
garbage collection. Here, linearity prevented aliasing in programs, enabling the
treatment of names as resources. Further, Ser Baker uncovered a relationship
between linearity and
stack machines that allow arbitrary manipulation on the top of the stack,
capturing a &lt;em&gt;low-level&lt;/em&gt; interpretation of linearity in
programming.&lt;/p&gt;
&lt;p&gt;Then, later quests by Sers Clarke, Potter, and
Noble and Sers Noble, Vitek, and Potter brought us the discovery of &lt;em&gt;ownership
types&lt;/em&gt;, a programming discipline that empowers the programmer with the
flexibility to control what kinds of aliasing patterns are allowed in their
programs. While Ser Baker addressed the question of
how to design a high-level language without garbage collection, these next
efforts address the question of how to control aliasing in programs to avoid
classic systems problems like &lt;em&gt;encapsulation violations&lt;/em&gt;,
&lt;em&gt;use-after-free bugs&lt;/em&gt;, and &lt;em&gt;data races&lt;/em&gt;. Here, we see an essential
insight --- rather than choose one for the whole language, one can give the
programmer a choice locally between uniqueness and mutability &lt;em&gt;or&lt;/em&gt;
sharedness and immutability (sometimes called &lt;em&gt;writing xor sharing&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;Around the same time, Sers Tofte and Talpin
set out on their own quests to enable more fine-grained
control of memory management in functional programming languages through the use
of &lt;em&gt;regions&lt;/em&gt;. These regions statically group objects into distinct sections
of memory which are allocated and deallocated together. In the ensuing years,
many worked on developing full-scale production languages that leveraged these
ideas to create a &lt;em&gt;safe systems programming language&lt;/em&gt;. Yet, for
a variety of reasons (not least of which a lack of large-scale engineering
investment), none of these really caught on. Still, the ideas and techniques
discovered on these quests moved the Knights of PL forward, helping to bring us
to today.&lt;/p&gt;
&lt;h1&gt;A New Lead?&lt;/h1&gt;
&lt;p&gt;In recent years, the Rust programming language has taken
off as the latest language at the intersection of low-level systems programming
and high-level applications programming --- bringing us the closest we have ever
gotten to the Holy Grail. Its rapid growth and promising design have caught the
attention of researchers and practitioners alike. To accomplish this, Rust integrates
many of these ideas discovered on prior quests --- including automatic memory
management without garbage collection, flexible
control over aliasing, and region-based memory
management --- into a novel framework called &lt;em&gt;borrow checking&lt;/em&gt;. But hailing from
industry knights, Rust and its &lt;em&gt;borrow checker&lt;/em&gt; lack the kinds of formal
specifications that enable many of the
reasoning techniques favored by the Knights of PL, and thus preventing their
benefits.&lt;/p&gt;
&lt;p&gt;For those uninitiated by the Knights of PL, I will try to make these benefits
concrete. Historically, formal reasoning has played an essential role in
developing new features for programming languages, ensuring the correctness of
languages and their compilers, and enabling programmers to reason more precisely
about their programs. For instance, Featherweight
Java and other similar efforts to formalize
Java were used to experiment with designs for generics and led to Java&#39;s
generics system being introduced in Java 1.5. As a squire myself, I have set out
to try to bring this kind of power and interest to Rust by producing a formal
account of the language, dubbed &lt;em&gt;Oxide&lt;/em&gt;, on my journey to knighthood.&lt;/p&gt;
&lt;p&gt;While there are some existing formalizations of Rust, none capture a
high-level understanding of Rust&#39;s essence (namely &lt;em&gt;ownership&lt;/em&gt; and
&lt;em&gt;borrowing&lt;/em&gt;). In particular, the first major effort,
Patina, formalized an early version of Rust which predates
much of the work to simplify and streamline the language, and was ultimately
left unfinished. The next effort, known as Rusty
Types, set out to characterize Rust-like type
systems, developing a formal calculus, &lt;em&gt;Metal&lt;/em&gt;, which relies on an
algorithmic formulation of borrow checking that is less expressive than both
Rust and Oxide. RustBelt, the most complete effort to
date, formalized a &lt;em&gt;low-level&lt;/em&gt;, intermediate language in
continuation-passing style, making it difficult to reason about ownership as a
&lt;em&gt;source-level&lt;/em&gt; concept. Finally, an early version of
Oxide oversimplified some parts of the language and
overcomplicated others. We have since revised and simplified Oxide greatly to
get at its &lt;em&gt;essence&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;In this post, I&#39;ll present the key intuitions behind Oxide,
wade a bit into some of the essential formal elements, and
finally explore some of the ramifications of this newfound understanding.
Our draft paper features a larger, and more complete account of Oxide.&lt;/p&gt;
&lt;h1&gt;Understanding the Borrow Checker&lt;/h1&gt;
&lt;p&gt;As alluded to already, the essence of Rust lies in its &lt;em&gt;borrow checker&lt;/em&gt;, a
novel approach to &lt;em&gt;ownership&lt;/em&gt;, which accounts for the most interesting
aspects of the language&#39;s type system (or &lt;em&gt;static semantics&lt;/em&gt;) and provides
justification for its claims to &lt;em&gt;memory safety&lt;/em&gt; and &lt;em&gt;data race freedom&lt;/em&gt;.
In this section, we work through a number of examples on our quest
to understand ownership and borrowing, and how they are ultimately captured in
Oxide.&lt;/p&gt;
&lt;h1&gt;Ownership for Great Good&lt;/h1&gt;
&lt;p&gt;The first element of Rust&#39;s &lt;em&gt;borrow checker&lt;/em&gt; is a notion of
&lt;em&gt;ownership&lt;/em&gt; that builds on the quests of Ser
Baker, which developed support for efficient reuse of
objects in memory using &lt;em&gt;linearity&lt;/em&gt;. In fact, there is a strong resemblance
between this half of Rust&#39;s borrow checker and Ser Baker&#39;s &#39;use-once&#39;
variables. We can view these ideas at work in
Rust in the following example:&lt;/p&gt;
&lt;pre class=&quot;language-rust&quot;&gt;&lt;code class=&quot;language-rust&quot;&gt;  &lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token type-definition class-name&quot;&gt;Point&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;u32&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;u32&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;mut&lt;/span&gt; pt &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Point&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; pt&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; y &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; pt&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// ERROR: pt was already moved&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, we declare a type &lt;code&gt;Point&lt;/code&gt; consisting of a pair of
unsigned 32-bit integers (denoted &lt;code&gt;u32&lt;/code&gt;). Then, on line 3, we create a new
&lt;code&gt;Point&lt;/code&gt; named &lt;code&gt;pt&lt;/code&gt;. We use &lt;code&gt;mut&lt;/code&gt; to mark that the binding for
&lt;code&gt;pt&lt;/code&gt; can be reassigned, and we say that this value is &lt;em&gt;owned&lt;/em&gt; by its
identifier &lt;code&gt;pt&lt;/code&gt;. Then, on line 4, we transfer ownership to &lt;code&gt;x&lt;/code&gt; by
&lt;em&gt;moving&lt;/em&gt; the value from &lt;code&gt;pt&lt;/code&gt;. After moving the value out of
&lt;code&gt;pt&lt;/code&gt;, we invalidate the old name, and thus, in the subsequent attempt to
use it on line 5, we encounter an error as &lt;code&gt;pt&lt;/code&gt; was already moved in the
previous line. With the exception of required type annotations, this program is
identical in Oxide, and produces the same error.&lt;/p&gt;
&lt;h1&gt;Borrowing for Flexibility&lt;/h1&gt;
&lt;p&gt;The second element of Rust&#39;s &lt;em&gt;borrow checker&lt;/em&gt; is known as &lt;em&gt;borrowing&lt;/em&gt;
and represents the language&#39;s main departure from ideas like &#39;use-once&#39;
variables. Rather than say that
&lt;em&gt;everything&lt;/em&gt; must be unique, Rust allows the programmer to locally make a
decision between using unique references with
unguarded mutation &lt;em&gt;or&lt;/em&gt; using shared references without such
mutation.&lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;https://aaronweiss.us/posts/2020-01-27-monty-pl-and-the-holy-grail/#fn1&quot; id=&quot;fnref1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; This flexibility takes inspiration from the
quests of Sers Noble, Clarke, Vitek, and Potter toward flexible alias protection
and ownership types. We can once again see this at work in Rust with an example:&lt;/p&gt;
&lt;pre class=&quot;language-rust&quot;&gt;&lt;code class=&quot;language-rust&quot;&gt;  &lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token type-definition class-name&quot;&gt;Point&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;u32&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;u32&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;mut&lt;/span&gt; pt &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Point&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; x &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;pt&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; y &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;pt&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// no error, sharing is okay!&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the above example, we replaced the &lt;em&gt;move&lt;/em&gt; expressions on lines 4 and 5
with &lt;em&gt;borrow&lt;/em&gt; expressions that create shared references to &lt;code&gt;pt&lt;/code&gt;. As
noted in the comment, this program does not produce an error because the
references specifically &lt;em&gt;allow&lt;/em&gt; this kind of sharing. However, unlike with
plain variable bindings (as in the last example), we cannot mutate through these
references, and attempts to do so would result in an error at compile-time.
However, the behavior changes when we try to mix shared and unique references to
the same place:&lt;/p&gt;
&lt;pre class=&quot;language-rust&quot;&gt;&lt;code class=&quot;language-rust&quot;&gt;  &lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token type-definition class-name&quot;&gt;Point&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;u32&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;u32&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;mut&lt;/span&gt; pt&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Point&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Point&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;token lifetime-annotation symbol&quot;&gt;&#39;a&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Point&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;mut&lt;/span&gt; pt&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; y&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;token lifetime-annotation symbol&quot;&gt;&#39;b&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Point&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;pt&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token comment&quot;&gt;//                 ^~~&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token comment&quot;&gt;// ERROR: cannot borrow pt while&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token comment&quot;&gt;//        a mutable loan to pt is live&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token punctuation&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;token comment&quot;&gt;// additional code that uses x and y&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this case, we&#39;ve changed the borrow expression on line 4 to create a unique
reference, and added explicit type annotations to our bindings on lines 3--5.
This produces an error because Rust forbids the creation of a shared reference
while a mutable &lt;em&gt;loan&lt;/em&gt; exists. Here, we use the word loan to refer to the
state introduced in the borrow checker (including the uniqueness of the loan and
its origin) by the creation of a reference. Regions&lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;https://aaronweiss.us/posts/2020-01-27-monty-pl-and-the-holy-grail/#fn2&quot; id=&quot;fnref2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt; in
Rust (denoted &lt;code&gt;&#39;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, etc.) can be understood as collections of
these loans which together statically approximate which pointers could be used
dynamically at a particular reference type. This is the sense in which Rust&#39;s
regions are distinct from the existing literature on region-based memory
management.&lt;/p&gt;
&lt;p&gt;While we were unable to create a second reference to the same place as an
existing unique reference in our past examples, Rust allows the programmer to
create two unique references to disjoint paths through the same object, as in
the following example:&lt;/p&gt;
&lt;pre class=&quot;language-rust&quot;&gt;&lt;code class=&quot;language-rust&quot;&gt;  &lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token type-definition class-name&quot;&gt;Point&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;u32&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;u32&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;mut&lt;/span&gt; pt&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Point&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Point&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;token lifetime-annotation symbol&quot;&gt;&#39;a&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;u32&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;mut&lt;/span&gt; pt&lt;span class=&quot;token number&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; y&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;token lifetime-annotation symbol&quot;&gt;&#39;b&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;u32&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;mut&lt;/span&gt; pt&lt;span class=&quot;token number&quot;&gt;.1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token comment&quot;&gt;// no error, our loans don&#39;t overlap!&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this example, we&#39;re borrowing from specific paths within &lt;code&gt;pt&lt;/code&gt; (namely,
the first and second projections respectively). Since these paths give a name to
the places being referenced, we refer to them as &lt;em&gt;places&lt;/em&gt;. Rust employs a
fine-grained notion of ownership allowing unique loans against non-overlapping
places within aggregate structures (like structs and tuples). Intuitively, this
is safe because the parts of memory referred to by each place (in this case,
&lt;code&gt;pt.0&lt;/code&gt; and &lt;code&gt;pt.1&lt;/code&gt;) do not overlap, and thus they represent portions
that can each be uniquely owned.&lt;/p&gt;
&lt;h1&gt;Formalizing Rust&lt;/h1&gt;
&lt;p&gt;These programs remain largely the same in Oxide, though I don&#39;t have the space
to reproduce them all here. There are three main differences from Rust. First,
we explicitly annotate the types of every binding. Second, acknowedgling the two
distinct roles &lt;code&gt;mut&lt;/code&gt; plays in Rust, I draw attention to its use as a
qualifier for the uniqueness of references (renaming it to &lt;code&gt;uniq&lt;/code&gt;). Third, I
shift the language we use to discuss regions or lifetimes. In particular, since
regions capture approximations of a reference&#39;s origin, I use the more precise
term &lt;em&gt;approximate provenances&lt;/em&gt;, and refer to their variable form
(&lt;code&gt;&#39;a&lt;/code&gt;, &lt;code&gt;&#39;b&lt;/code&gt;, etc.) as &lt;em&gt;provenance variables&lt;/em&gt;. With these
differences in mind, let&#39;s revisit our last example after translating it into
Oxide:&lt;/p&gt;
&lt;pre class=&quot;language-rust&quot;&gt;&lt;code class=&quot;language-rust&quot;&gt;  &lt;span class=&quot;token keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;token type-definition class-name&quot;&gt;Point&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;u32&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;u32&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; pt&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Point&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Point&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;token lifetime-annotation symbol&quot;&gt;&#39;x&lt;/span&gt; uniq &lt;span class=&quot;token keyword&quot;&gt;u32&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;token lifetime-annotation symbol&quot;&gt;&#39;x&lt;/span&gt; uniq pt&lt;span class=&quot;token number&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token keyword&quot;&gt;let&lt;/span&gt; y&lt;span class=&quot;token punctuation&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;token lifetime-annotation symbol&quot;&gt;&#39;y&lt;/span&gt; uniq &lt;span class=&quot;token keyword&quot;&gt;u32&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;token lifetime-annotation symbol&quot;&gt;&#39;y&lt;/span&gt; uniq pt&lt;span class=&quot;token number&quot;&gt;.1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;&lt;br /&gt;  &lt;span class=&quot;token comment&quot;&gt;// no error, our loans are disjoint&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As already noted, the type annotations on lines 3--5 (i.e. for each let binding)
are now required, and we replaced &lt;code&gt;mut&lt;/code&gt; with the qualifier &lt;code&gt;uniq&lt;/code&gt;,
denoting that the references on lines 4 and 5 are unique. The program is
otherwise unchanged from the Rust version. Then, as in the original, the Oxide
version of the program type checks successfully because the origins of the loans
created on lines 4 and 5 are disjoint. That is, we know that &lt;code&gt;x&lt;/code&gt; can
only have originated from &lt;code&gt;pt.0&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; only from &lt;code&gt;pt.1&lt;/code&gt;, and
that &lt;code&gt;pt.0&lt;/code&gt; and &lt;code&gt;pt.1&lt;/code&gt; refer to disjoint portions of memory.&lt;/p&gt;
&lt;p&gt;How did the type-checker determine this? First, while type-checking the let
bindings, Oxide computes the concrete values for any provenance variables that
appear in their types (such as &lt;code&gt;&#39;x&lt;/code&gt; and &lt;code&gt;&#39;y&lt;/code&gt;). Here, it determines
that &lt;code&gt;&#39;x&lt;/code&gt; will be mapped to &lt;code&gt;{ uniq pt.0 }&lt;/code&gt; and &lt;code&gt;&#39;y&lt;/code&gt; to &lt;code&gt;{ uniq pt.1 }&lt;/code&gt;. These
mappings tell
us the potential provenance of each reference, where in this simple case, there
is exactly one for each. Then, when type-checking the borrow expressions, Oxide
looks at its place environment Γ to determine that there are no live
loans to any place that is somehow joint with the place we&#39;re borrowing from. In this
case, on line 5, the type-checker looks at the current environment and finds
that the only live loan is &lt;code&gt;uniq pt.0&lt;/code&gt;, and since &lt;code&gt;pt.0&lt;/code&gt; and &lt;code&gt;pt.1&lt;/code&gt; are disjoint,
the second borrow also type checks.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Information Loss&lt;/em&gt;. Though the example we just saw has a precise origin
for each reference, provenances are, in general, approximate because of join
points in the program. For example, in an if expression, we might create a new
set of loans in one branch, and a different set of loans in the other branch. To
keep the type-checker sound, we need to be conservative and act as if
&lt;em&gt;both&lt;/em&gt; sets of loans are live, and so, we combine the return types and
environments from each branch.&lt;/p&gt;
&lt;h1&gt;Oxide, More Formally&lt;/h1&gt;
&lt;p&gt;We&#39;ve now seen roughly enough to describe Oxide in more formal detail. First,
note that loans are created and destroyed over the course of the program. This
means that our type system has to somehow track the flow of this information as
it type-checks each expression. As such, we use an environment-passing typing
judgment where the output of the judgment includes an updated environment that
may have added or removed some bindings (and thus created or destroyed some
loans). We write this judgment as $&#92;Sigma; ; &#92;Delta; ; &#92;Gamma &#92;vdash e : &#92;tau &#92;Rightarrow &#92;Gamma^&#92;prime$,
which can be read as:
under the global environment $&#92;Sigma$ (containing top-level program
definitions including both function and type definitions), the type variable
environment $&#92;Delta$ (tracking in-scope type and provenance variables), and
the place environment $&#92;Gamma$ (mapping places to their respective types),
the expression $e$ has type $&#92;tau$ and produces an updated output
environment $&#92;Gamma^&#92;prime$, which contains all of the remaining places
&lt;em&gt;after&lt;/em&gt; type-checking the expression $e$.&lt;/p&gt;
&lt;p&gt;&#92;begin{figure_[H]
&#92;begin{mathpar_
&#92;TMove &#92;and &#92;TBorrow
&#92;end{mathpar_
&#92;caption{The essence of Oxide._
&#92;label{fig:essence_
&#92;end{figure_&lt;/p&gt;
&lt;p&gt;Above, we see two typing rules that capture the essence of how
Oxide models the behavior of Rust&#39;s borrow checker. Following the traditions of
the Knights of PL, these rules are written in the style of &lt;em&gt;natural
deduction&lt;/em&gt; where each rule can be read as ``if we have a proof of the
statements above the horizontal line, then we can combine them to construct a
proof of the statement below the line.&amp;quot; As such, to understand our two rules,
it is necessary to understand the meaning of the judgement in their premise
($&#92;Sigma; ; &#92;Gamma ; &#92;vdash_&#92;omega ; p : &#92;tau &#92;Rightarrow { ; &#92;ell_1 ; &#92;dots ; &#92;ell_n ; }$).&lt;/p&gt;
&lt;p&gt;This judgment, called ownership safety, says &amp;quot;in the place environment
$&#92;Gamma$, it is safe to use the place $&#92;pi$ (of type $&#92;tau$)
$&#92;mu$-ly.&amp;quot; That is, if we have a derivation when $&#92;mu$ is unique, we
know that we can use the place $&#92;pi$ uniquely because we have a proof that
there are no live loans against the section of memory that $&#92;pi$
represents. This instance of the judgment appears in the premise of
$&#92;texttt{T-Move}$ because we know that it is only safe to move a value &lt;em&gt;out&lt;/em&gt;
of the environment when it is the sole name for that value. Further, when we
have a derivation of this ownership safety judgment where $&#92;mu$ is $&#92;texttt{imm}$,
we know that we can use the place $&#92;pi$ sharedly because we have a proof
that there are no live &lt;em&gt;unique&lt;/em&gt; loans against the section of memory that
$&#92;pi$ represents. In the case of borrowing (as in $&#92;texttt{T-Borrow}$), these
two meanings of ownership safety correspond exactly to the intuition behind when
a $&#92;mu$-loan is safe to create.&lt;/p&gt;
&lt;p&gt;Since this judgment is the one that captures the essence of Rust&#39;s ownership
semantics, we understand Rust&#39;s borrow checking system as ultimately being a
system for statically building a proof that data in memory is either
&lt;em&gt;uniquely owned&lt;/em&gt; (and thus able to allow unguarded mutation) or
&lt;em&gt;collectively shared&lt;/em&gt;, but not both. To do so, intuitively, the
ownership safety judgment looks through all of the approximate provenances found
within types in $&#92;Gamma$, and ensures that none of the loans they contain
conflict with the place $&#92;pi$ in question. For a $&#92;texttt{uniq}$ loan, a conflict
occurs if any loan maps to an overlapping place, but for a $&#92;texttt{shrd}$ loan, a
conflict occurs only when a $&#92;texttt{uniq}$ loan maps to an overlapping place.&lt;/p&gt;
&lt;p&gt;For both more examples and more details about the Oxide formalism, interested
readers should look at the full article by Weiss, Patterson, Matsakis, and
Ahmed.&lt;/p&gt;
&lt;h1&gt;Oxide in Context&lt;/h1&gt;
&lt;p&gt;As with prior quests directed at understanding real world languages, Oxide
provides a formal framework for reasoning about the behavior of programs in one
such language --- i.e. programs in surface-level Rust. One prominent example is
Featherweight Java which supported a wealth
of new research on Java. And as with prior quests such as this, a number of
promising avenues for future work on Rust open up that leverage our newfound
reasoning ability with Oxide.&lt;/p&gt;
&lt;h1&gt;Formal Verification&lt;/h1&gt;
&lt;p&gt;One of the unfortunate gaps in Rust programming today is the lack of effective
tools for proving properties (such as functional correctness) of Rust programs.
There are some early efforts already to try to improve this
situation~&#92;cite{ullrich16:electrolysis, toman15:crust, baranowski18:smack,
astrauskas18:rust-viper_, but without a semantics the possibilities are
limited. For example, the work by Astrauskas et
al. builds verification support for Rust into
Viper, but uses an ad-hoc subset of the language without
support for shared references. We believe that our work on Oxide can help extend
such work to support more Rust code, and will enable further verification
techniques like those seen in $F^&#92;star$ and Liquid
Haskell.&lt;/p&gt;
&lt;h1&gt;Verified Compilation&lt;/h1&gt;
&lt;p&gt;Given the prevalence of memory safety issues in security vulnerabilities, Rust&#39;s
guarantees of memory safety lend themselves well to building security-critical
applications. However, many security-critical applications (like cryptography
code) require that these guarantees still hold after compilation, and further
require a guarantee that timing of the program is preserved under compilation
(to avoid the introduction of side-channel attacks). Rust&#39;s existing compiler
toolchain --- which is built using LLVM --- is unable to
formally prove preservation of these kinds of guarantees, and indeed, for
timing, optimizations are designed to do almost entirely the opposite. As such,
another avenue for future work would be to develop a verified compiler for Rust
that preserves program semantics and timing behavior, perhaps by compilation to
Vellvm.&lt;/p&gt;
&lt;h1&gt;Language-based Security&lt;/h1&gt;
&lt;p&gt;We also view Oxide as an enabler for future work on extending techniques from
the literature on language-based security to Rust. In particular, one could
imagine building support for dynamic or static information-flow control atop
Oxide as a formalization (for which we can actually prove theorems about these
extensions) alongside a practical implementation for the official Rust compiler.
Similarly, Oxide can support building extensions for data-oblivious computing
(as in work by Zahur and Evans) and relaxed
noninterference (as in recent work by Cruz et al.).&lt;/p&gt;
&lt;h1&gt;The Quest Marches On…&lt;/h1&gt;
&lt;p&gt;As argued early on, Rust is the closest the Knights of PL have
gotten to the Holy Grail of Programming --- the language that provides
programmers all the benefits of high-level abstractions and all the fine-grained
control of systems programming. With Oxide, we now have the tools to interact
with and build on Rust more formally. This work too will help bring us closer to
the Grail. Yet, we also remain so far! Still, I --- forever the fool ---
continue on my own search.&lt;/p&gt;
&lt;hr class=&quot;footnotes-sep&quot; /&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;ol class=&quot;footnotes-list&quot;&gt;
&lt;li id=&quot;fn1&quot; class=&quot;footnote-item&quot;&gt;&lt;p&gt;The use of &amp;quot;such&amp;quot; here is intentional as dynamically guarded mutation, e.g. using a &lt;code&gt;Mutex&lt;/code&gt;, is still allowed through a shared reference. Indeed, this is precisely what makes such guards &lt;em&gt;useful&lt;/em&gt; when programming. &lt;a href=&quot;https://aaronweiss.us/posts/2020-01-27-monty-pl-and-the-holy-grail/#fnref1&quot; class=&quot;footnote-backref&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn2&quot; class=&quot;footnote-item&quot;&gt;&lt;p&gt;Previously, Rust used the term &lt;em&gt;lifetime&lt;/em&gt;, but recent efforts on a borrow checker rewrite called Polonius have been using the term region. &lt;a href=&quot;https://aaronweiss.us/posts/2020-01-27-monty-pl-and-the-holy-grail/#fnref2&quot; class=&quot;footnote-backref&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</content>
  </entry>
</feed>
